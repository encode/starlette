{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p> \u2728 The little ASGI framework that shines. \u2728 </p> <p> </p> <p>Documentation: https://www.starlette.io</p> <p>Source Code: https://github.com/encode/starlette</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Starlette is a lightweight ASGI framework/toolkit, which is ideal for building async web services in Python.</p> <p>It is production-ready, and gives you the following:</p> <ul> <li>A lightweight, low-complexity HTTP web framework.</li> <li>WebSocket support.</li> <li>In-process background tasks.</li> <li>Startup and shutdown events.</li> <li>Test client built on <code>httpx</code>.</li> <li>CORS, GZip, Static Files, Streaming responses.</li> <li>Session and Cookie support.</li> <li>100% test coverage.</li> <li>100% type annotated codebase.</li> <li>Few hard dependencies.</li> <li>Compatible with <code>asyncio</code> and <code>trio</code> backends.</li> <li>Great overall performance against independent benchmarks.</li> </ul>"},{"location":"#sponsorship","title":"Sponsorship","text":"<p>Starlette is an open-source project that relies on community support. You can help us maintain and improve the framework by becoming a sponsor.</p> \ud83c\udfc6 Our Gold Sponsor <p>Modern, fast web framework for building APIs with Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install starlette\n</code></pre> <p>You'll also want to install an ASGI server, such as uvicorn, daphne, or hypercorn.</p> <pre><code>pip install uvicorn\n</code></pre>"},{"location":"#example","title":"Example","text":"main.py<pre><code>from starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\n\nasync def homepage(request):\n    return JSONResponse({'hello': 'world'})\n\n\napp = Starlette(debug=True, routes=[\n    Route('/', homepage),\n])\n</code></pre> <p>Then run the application...</p> <pre><code>uvicorn main:app\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Starlette only requires <code>anyio</code>, and the following dependencies are optional:</p> <ul> <li><code>httpx</code> - Required if you want to use the <code>TestClient</code>.</li> <li><code>jinja2</code> - Required if you want to use <code>Jinja2Templates</code>.</li> <li><code>python-multipart</code> - Required if you want to support form parsing, with <code>request.form()</code>.</li> <li><code>itsdangerous</code> - Required for <code>SessionMiddleware</code> support.</li> <li><code>pyyaml</code> - Required for <code>SchemaGenerator</code> support.</li> </ul> <p>You can install all of these with <code>pip install starlette[full]</code>.</p>"},{"location":"#framework-or-toolkit","title":"Framework or Toolkit","text":"<p>Starlette is designed to be used either as a complete framework, or as an ASGI toolkit. You can use any of its components independently.</p> main.py<pre><code>from starlette.responses import PlainTextResponse\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = PlainTextResponse('Hello, world!')\n    await response(scope, receive, send)\n</code></pre> <p>Run the <code>app</code> application in <code>main.py</code>:</p> <pre><code>$ uvicorn main:app\nINFO: Started server process [11509]\nINFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\n</code></pre> <p>Run uvicorn with <code>--reload</code> to enable auto-reloading on code changes.</p>"},{"location":"#modularity","title":"Modularity","text":"<p>The modularity that Starlette is designed on promotes building re-usable components that can be shared between any ASGI framework. This should enable an ecosystem of shared middleware and mountable applications.</p> <p>The clean API separation also means it's easier to understand each component in isolation.</p> <p>Starlette is BSD licensed code.Designed &amp; crafted with care.\u2014 \u2b50\ufe0f \u2014</p>"},{"location":"applications/","title":"Applications","text":"API Reference <p>Starlette includes an application class <code>Starlette</code> that nicely ties together all of its other functionality.</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom starlette.applications import Starlette\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route, Mount, WebSocketRoute\nfrom starlette.staticfiles import StaticFiles\n\n\ndef homepage(request):\n    return PlainTextResponse('Hello, world!')\n\ndef user_me(request):\n    username = \"John Doe\"\n    return PlainTextResponse('Hello, %s!' % username)\n\ndef user(request):\n    username = request.path_params['username']\n    return PlainTextResponse('Hello, %s!' % username)\n\nasync def websocket_endpoint(websocket):\n    await websocket.accept()\n    await websocket.send_text('Hello, websocket!')\n    await websocket.close()\n\n@asynccontextmanager\nasync def lifespan(app):\n    print('Startup')\n    yield\n    print('Shutdown')\n\n\nroutes = [\n    Route('/', homepage),\n    Route('/user/me', user_me),\n    Route('/user/{username}', user),\n    WebSocketRoute('/ws', websocket_endpoint),\n    Mount('/static', StaticFiles(directory=\"static\")),\n]\n\napp = Starlette(debug=True, routes=routes, lifespan=lifespan)\n</code></pre>"},{"location":"applications/#starlette.applications.Starlette","title":"starlette.applications.Starlette","text":"<pre><code>Starlette(\n    debug: bool = False,\n    routes: Sequence[BaseRoute] | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    exception_handlers: (\n        Mapping[Any, ExceptionHandler] | None\n    ) = None,\n    on_startup: Sequence[Callable[[], Any]] | None = None,\n    on_shutdown: Sequence[Callable[[], Any]] | None = None,\n    lifespan: Lifespan[AppType] | None = None,\n)\n</code></pre> <p>Creates an Starlette application.</p> <p>Parameters:</p> <ul> <li> <code>debug</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Boolean indicating if debug tracebacks should be returned on errors.</p> </li> <li> <code>routes</code>               (<code>Sequence[BaseRoute] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of routes to serve incoming HTTP and WebSocket requests.</p> </li> <li> <code>middleware</code>               (<code>Sequence[Middleware] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of middleware to run for every request. A starlette application will always automatically include two middleware classes. <code>ServerErrorMiddleware</code> is added as the very outermost middleware, to handle any uncaught errors occurring anywhere in the entire stack. <code>ExceptionMiddleware</code> is added as the very innermost middleware, to deal with handled exception cases occurring in the routing or endpoints.</p> </li> <li> <code>exception_handlers</code>               (<code>Mapping[Any, ExceptionHandler] | None</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of either integer status codes, or exception class types onto callables which handle the exceptions. Exception handler callables should be of the form <code>handler(request, exc) -&gt; response</code> and may be either standard functions, or async functions.</p> </li> <li> <code>on_startup</code>               (<code>Sequence[Callable[[], Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of callables to run on application startup. Startup handler callables do not take any arguments, and may be either standard functions, or async functions.</p> </li> <li> <code>on_shutdown</code>               (<code>Sequence[Callable[[], Any]] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of callables to run on application shutdown. Shutdown handler callables do not take any arguments, and may be either standard functions, or async functions.</p> </li> <li> <code>lifespan</code>               (<code>Lifespan[AppType] | None</code>, default:                   <code>None</code> )           \u2013            <p>A lifespan context function, which can be used to perform startup and shutdown tasks. This is a newer style that replaces the <code>on_startup</code> and <code>on_shutdown</code> handlers. Use one or the other, not both.</p> </li> </ul>"},{"location":"applications/#storing-state-on-the-app-instance","title":"Storing state on the app instance","text":"<p>You can store arbitrary extra state on the application instance, using the generic <code>app.state</code> attribute.</p> <p>For example:</p> <pre><code>app.state.ADMIN_EMAIL = 'admin@example.org'\n</code></pre>"},{"location":"applications/#accessing-the-app-instance","title":"Accessing the app instance","text":"<p>Where a <code>request</code> is available (i.e. endpoints and middleware), the app is available on <code>request.app</code>.</p>"},{"location":"authentication/","title":"Authentication","text":"<p>Starlette offers a simple but powerful interface for handling authentication and permissions. Once you've installed <code>AuthenticationMiddleware</code> with an appropriate authentication backend the <code>request.user</code> and <code>request.auth</code> interfaces will be available in your endpoints.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.authentication import (\n    AuthCredentials, AuthenticationBackend, AuthenticationError, SimpleUser\n)\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.authentication import AuthenticationMiddleware\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\nimport base64\nimport binascii\n\n\nclass BasicAuthBackend(AuthenticationBackend):\n    async def authenticate(self, conn):\n        if \"Authorization\" not in conn.headers:\n            return\n\n        auth = conn.headers[\"Authorization\"]\n        try:\n            scheme, credentials = auth.split()\n            if scheme.lower() != 'basic':\n                return\n            decoded = base64.b64decode(credentials).decode(\"ascii\")\n        except (ValueError, UnicodeDecodeError, binascii.Error) as exc:\n            raise AuthenticationError('Invalid basic auth credentials')\n\n        username, _, password = decoded.partition(\":\")\n        # TODO: You'd want to verify the username and password here.\n        return AuthCredentials([\"authenticated\"]), SimpleUser(username)\n\n\nasync def homepage(request):\n    if request.user.is_authenticated:\n        return PlainTextResponse('Hello, ' + request.user.display_name)\n    return PlainTextResponse('Hello, you')\n\nroutes = [\n    Route(\"/\", endpoint=homepage)\n]\n\nmiddleware = [\n    Middleware(AuthenticationMiddleware, backend=BasicAuthBackend())\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre>"},{"location":"authentication/#users","title":"Users","text":"<p>Once <code>AuthenticationMiddleware</code> is installed the <code>request.user</code> interface will be available to endpoints or other middleware.</p> <p>This interface should subclass <code>BaseUser</code>, which provides two properties, as well as whatever other information your user model includes.</p> <ul> <li><code>.is_authenticated</code></li> <li><code>.display_name</code></li> </ul> <p>Starlette provides two built-in user implementations: <code>UnauthenticatedUser()</code>, and <code>SimpleUser(username)</code>.</p>"},{"location":"authentication/#authcredentials","title":"AuthCredentials","text":"<p>It is important that authentication credentials are treated as separate concept from users. An authentication scheme should be able to restrict or grant particular privileges independently of the user identity.</p> <p>The <code>AuthCredentials</code> class provides the basic interface that <code>request.auth</code> exposes:</p> <ul> <li><code>.scopes</code></li> </ul>"},{"location":"authentication/#permissions","title":"Permissions","text":"<p>Permissions are implemented as an endpoint decorator, that enforces that the incoming request includes the required authentication scopes.</p> <pre><code>from starlette.authentication import requires\n\n\n@requires('authenticated')\nasync def dashboard(request):\n    ...\n</code></pre> <p>You can include either one or multiple required scopes:</p> <pre><code>from starlette.authentication import requires\n\n\n@requires(['authenticated', 'admin'])\nasync def dashboard(request):\n    ...\n</code></pre> <p>By default 403 responses will be returned when permissions are not granted. In some cases you might want to customize this, for example to hide information about the URL layout from unauthenticated users.</p> <pre><code>from starlette.authentication import requires\n\n\n@requires(['authenticated', 'admin'], status_code=404)\nasync def dashboard(request):\n    ...\n</code></pre> <p>Note</p> <p>The <code>status_code</code> parameter is not supported with WebSockets. The 403 (Forbidden) status code will always be used for those.</p> <p>Alternatively you might want to redirect unauthenticated users to a different page.</p> <pre><code>from starlette.authentication import requires\n\n\nasync def homepage(request):\n    ...\n\n\n@requires('authenticated', redirect='homepage')\nasync def dashboard(request):\n    ...\n</code></pre> <p>When redirecting users, the page you redirect them to will include URL they originally requested at the <code>next</code> query param:</p> <pre><code>from starlette.authentication import requires\nfrom starlette.responses import RedirectResponse\n\n\n@requires('authenticated', redirect='login')\nasync def admin(request):\n    ...\n\n\nasync def login(request):\n    if request.method == \"POST\":\n        # Now that the user is authenticated,\n        # we can send them to their original request destination\n        if request.user.is_authenticated:\n            next_url = request.query_params.get(\"next\")\n            if next_url:\n                return RedirectResponse(next_url)\n            return RedirectResponse(\"/\")\n</code></pre> <p>For class-based endpoints, you should wrap the decorator around a method on the class.</p> <pre><code>from starlette.authentication import requires\nfrom starlette.endpoints import HTTPEndpoint\n\n\nclass Dashboard(HTTPEndpoint):\n    @requires(\"authenticated\")\n    async def get(self, request):\n        ...\n</code></pre>"},{"location":"authentication/#custom-authentication-error-responses","title":"Custom authentication error responses","text":"<p>You can customise the error response sent when a <code>AuthenticationError</code> is raised by an auth backend:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.authentication import AuthenticationMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\n\n\ndef on_auth_error(request: Request, exc: Exception):\n    return JSONResponse({\"error\": str(exc)}, status_code=401)\n\napp = Starlette(\n    middleware=[\n        Middleware(AuthenticationMiddleware, backend=BasicAuthBackend(), on_error=on_auth_error),\n    ],\n)\n</code></pre>"},{"location":"background/","title":"Background Tasks","text":"<p>Starlette includes a <code>BackgroundTask</code> class for in-process background tasks.</p> <p>A background task should be attached to a response, and will run only once the response has been sent.</p>"},{"location":"background/#background-task","title":"Background Task","text":"<p>Used to add a single background task to a response.</p> <p>Signature: <code>BackgroundTask(func, *args, **kwargs)</code></p> <pre><code>from starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\nfrom starlette.background import BackgroundTask\n\n\n...\n\nasync def signup(request):\n    data = await request.json()\n    username = data['username']\n    email = data['email']\n    task = BackgroundTask(send_welcome_email, to_address=email)\n    message = {'status': 'Signup successful'}\n    return JSONResponse(message, background=task)\n\nasync def send_welcome_email(to_address):\n    ...\n\n\nroutes = [\n    ...\n    Route('/user/signup', endpoint=signup, methods=['POST'])\n]\n\napp = Starlette(routes=routes)\n</code></pre>"},{"location":"background/#backgroundtasks","title":"BackgroundTasks","text":"<p>Used to add multiple background tasks to a response.</p> <p>Signature: <code>BackgroundTasks(tasks=[])</code></p> <pre><code>from starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.background import BackgroundTasks\n\nasync def signup(request):\n    data = await request.json()\n    username = data['username']\n    email = data['email']\n    tasks = BackgroundTasks()\n    tasks.add_task(send_welcome_email, to_address=email)\n    tasks.add_task(send_admin_notification, username=username)\n    message = {'status': 'Signup successful'}\n    return JSONResponse(message, background=tasks)\n\nasync def send_welcome_email(to_address):\n    ...\n\nasync def send_admin_notification(username):\n    ...\n\nroutes = [\n    Route('/user/signup', endpoint=signup, methods=['POST'])\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>Important</p> <p>The tasks are executed in order. In case one of the tasks raises an exception, the following tasks will not get the opportunity to be executed.</p>"},{"location":"config/","title":"Configuration","text":"<p>Starlette encourages a strict separation of configuration from code, following the twelve-factor pattern.</p> <p>Configuration should be stored in environment variables, or in a <code>.env</code> file that is not committed to source control.</p> main.py<pre><code>from sqlalchemy import create_engine\nfrom starlette.applications import Starlette\nfrom starlette.config import Config\nfrom starlette.datastructures import CommaSeparatedStrings, Secret\n\n# Config will be read from environment variables and/or \".env\" files.\nconfig = Config(\".env\")\n\nDEBUG = config('DEBUG', cast=bool, default=False)\nDATABASE_URL = config('DATABASE_URL')\nSECRET_KEY = config('SECRET_KEY', cast=Secret)\nALLOWED_HOSTS = config('ALLOWED_HOSTS', cast=CommaSeparatedStrings)\n\napp = Starlette(debug=DEBUG)\nengine = create_engine(DATABASE_URL)\n...\n</code></pre> .env<pre><code># Don't commit this to source control.\n# Eg. Include \".env\" in your `.gitignore` file.\nDEBUG=True\nDATABASE_URL=postgresql://user:password@localhost:5432/database\nSECRET_KEY=43n080musdfjt54t-09sdgr\nALLOWED_HOSTS=127.0.0.1, localhost\n</code></pre>"},{"location":"config/#configuration-precedence","title":"Configuration precedence","text":"<p>The order in which configuration values are read is:</p> <ul> <li>From an environment variable.</li> <li>From the <code>.env</code> file.</li> <li>The default value given in <code>config</code>.</li> </ul> <p>If none of those match, then <code>config(...)</code> will raise an error.</p>"},{"location":"config/#secrets","title":"Secrets","text":"<p>For sensitive keys, the <code>Secret</code> class is useful, since it helps minimize occasions where the value it holds could leak out into tracebacks or other code introspection.</p> <p>To get the value of a <code>Secret</code> instance, you must explicitly cast it to a string. You should only do this at the point at which the value is used.</p> <pre><code>&gt;&gt;&gt; from myproject import settings\n&gt;&gt;&gt; settings.SECRET_KEY\nSecret('**********')\n&gt;&gt;&gt; str(settings.SECRET_KEY)\n'98n349$%8b8-7yjn0n8y93T$23r'\n</code></pre> <p>Tip</p> <p>You can use <code>DatabaseURL</code> from <code>databases</code> package here to store database URLs and avoid leaking them in the logs.</p>"},{"location":"config/#commaseparatedstrings","title":"CommaSeparatedStrings","text":"<p>For holding multiple inside a single config key, the <code>CommaSeparatedStrings</code> type is useful.</p> <pre><code>&gt;&gt;&gt; from myproject import settings\n&gt;&gt;&gt; print(settings.ALLOWED_HOSTS)\nCommaSeparatedStrings(['127.0.0.1', 'localhost'])\n&gt;&gt;&gt; print(list(settings.ALLOWED_HOSTS))\n['127.0.0.1', 'localhost']\n&gt;&gt;&gt; print(len(settings.ALLOWED_HOSTS))\n2\n&gt;&gt;&gt; print(settings.ALLOWED_HOSTS[0])\n'127.0.0.1'\n</code></pre>"},{"location":"config/#reading-or-modifying-the-environment","title":"Reading or modifying the environment","text":"<p>In some cases you might want to read or modify the environment variables programmatically. This is particularly useful in testing, where you may want to override particular keys in the environment.</p> <p>Rather than reading or writing from <code>os.environ</code>, you should use Starlette's <code>environ</code> instance. This instance is a mapping onto the standard <code>os.environ</code> that additionally protects you by raising an error if any environment variable is set after the point that it has already been read by the configuration.</p> <p>If you're using <code>pytest</code>, then you can setup any initial environment in <code>tests/conftest.py</code>.</p> tests/conftest.py<pre><code>from starlette.config import environ\n\nenviron['DEBUG'] = 'TRUE'\n</code></pre>"},{"location":"config/#reading-prefixed-environment-variables","title":"Reading prefixed environment variables","text":"<p>You can namespace the environment variables by setting <code>env_prefix</code> argument.</p> myproject/settings.py<pre><code>import os\n\nfrom starlette.config import Config\n\nos.environ['APP_DEBUG'] = 'yes'\nos.environ['ENVIRONMENT'] = 'dev'\n\nconfig = Config(env_prefix='APP_')\n\nDEBUG = config('DEBUG') # lookups APP_DEBUG, returns \"yes\"\nENVIRONMENT = config('ENVIRONMENT') # lookups APP_ENVIRONMENT, raises KeyError as variable is not defined\n</code></pre>"},{"location":"config/#a-full-example","title":"A full example","text":"<p>Structuring large applications can be complex. You need proper separation of configuration and code, database isolation during tests, separate test and production databases, etc...</p> <p>Here we'll take a look at a complete example, that demonstrates how we can start to structure an application.</p> <p>First, let's keep our settings, our database table definitions, and our application logic separated:</p> myproject/settings.py<pre><code>from starlette.config import Config\nfrom starlette.datastructures import Secret\n\nconfig = Config(\".env\")\n\nDEBUG = config('DEBUG', cast=bool, default=False)\nSECRET_KEY = config('SECRET_KEY', cast=Secret)\n\nDATABASE_URL = config('DATABASE_URL')\n</code></pre> myproject/tables.py<pre><code>import sqlalchemy\n\n# Database table definitions.\nmetadata = sqlalchemy.MetaData()\n\norganisations = sqlalchemy.Table(\n    ...\n)\n</code></pre> myproject/app.py<pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.sessions import SessionMiddleware\nfrom starlette.routing import Route\n\nfrom myproject import settings\n\n\nasync def homepage(request):\n    ...\n\nroutes = [\n    Route(\"/\", endpoint=homepage)\n]\n\nmiddleware = [\n    Middleware(\n        SessionMiddleware,\n        secret_key=settings.SECRET_KEY,\n    )\n]\n\napp = Starlette(debug=settings.DEBUG, routes=routes, middleware=middleware)\n</code></pre> <p>Now let's deal with our test configuration. We'd like to create a new test database every time the test suite runs, and drop it once the tests complete. We'd also like to ensure</p> tests/conftest.py<pre><code>from starlette.config import environ\nfrom starlette.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy_utils import create_database, database_exists, drop_database\n\n# This line would raise an error if we use it after 'settings' has been imported.\nenviron['DEBUG'] = 'TRUE'\n\nfrom myproject import settings\nfrom myproject.app import app\nfrom myproject.tables import metadata\n\n\n@pytest.fixture(autouse=True, scope=\"session\")\ndef setup_test_database():\n    \"\"\"\n    Create a clean test database every time the tests are run.\n    \"\"\"\n    url = settings.DATABASE_URL\n    engine = create_engine(url)\n    assert not database_exists(url), 'Test database already exists. Aborting tests.'\n    create_database(url)             # Create the test database.\n    metadata.create_all(engine)      # Create the tables.\n    yield                            # Run the tests.\n    drop_database(url)               # Drop the test database.\n\n\n@pytest.fixture()\ndef client():\n    \"\"\"\n    Make a 'client' fixture available to test cases.\n    \"\"\"\n    # Our fixture is created within a context manager. This ensures that\n    # application lifespan runs for every test case.\n    with TestClient(app) as test_client:\n        yield test_client\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for being interested in contributing to Starlette. There are many ways you can contribute to the project:</p> <ul> <li>Try Starlette and report bugs/issues you find</li> <li>Implement new features</li> <li>Review Pull Requests of others</li> <li>Write documentation</li> <li>Participate in discussions</li> </ul>"},{"location":"contributing/#reporting-bugs-or-other-issues","title":"Reporting Bugs or Other Issues","text":"<p>Found something that Starlette should support? Stumbled upon some unexpected behaviour?</p> <p>Contributions should generally start out with a discussion. Possible bugs may be raised as a \"Potential Issue\" discussion, feature requests may be raised as an \"Ideas\" discussion. We can then determine if the discussion needs to be escalated into an \"Issue\" or not, or if we'd consider a pull request.</p> <p>Try to be more descriptive as you can and in case of a bug report, provide as much information as possible like:</p> <ul> <li>OS platform</li> <li>Python version</li> <li>Installed dependencies and versions (<code>python -m pip freeze</code>)</li> <li>Code snippet</li> <li>Error traceback</li> </ul> <p>You should always try to reduce any examples to the simplest possible case that demonstrates the issue.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>To start developing Starlette, create a fork of the Starlette repository on GitHub.</p> <p>Then clone your fork with the following command replacing <code>YOUR-USERNAME</code> with your GitHub username:</p> <pre><code>$ git clone https://github.com/YOUR-USERNAME/starlette\n</code></pre> <p>You can now install the project and its dependencies using:</p> <pre><code>$ cd starlette\n$ scripts/install\n</code></pre>"},{"location":"contributing/#testing-and-linting","title":"Testing and Linting","text":"<p>We use custom shell scripts to automate testing, linting, and documentation building workflow.</p> <p>To run the tests, use:</p> <pre><code>$ scripts/test\n</code></pre> <p>Any additional arguments will be passed to <code>pytest</code>. See the pytest documentation for more information.</p> <p>For example, to run a single test script:</p> <pre><code>$ scripts/test tests/test_application.py\n</code></pre> <p>To run the code auto-formatting:</p> <pre><code>$ scripts/lint\n</code></pre> <p>Lastly, to run code checks separately (they are also run as part of <code>scripts/test</code>), run:</p> <pre><code>$ scripts/check\n</code></pre>"},{"location":"contributing/#documenting","title":"Documenting","text":"<p>Documentation pages are located under the <code>docs/</code> folder.</p> <p>To run the documentation site locally (useful for previewing changes), use:</p> <pre><code>$ scripts/docs\n</code></pre>"},{"location":"contributing/#resolving-build-ci-failures","title":"Resolving Build / CI Failures","text":"<p>Once you've submitted your pull request, the test suite will automatically run, and the results will show up in GitHub. If the test suite fails, you'll want to click through to the \"Details\" link, and try to identify why the test suite failed.</p> <p> </p> <p>Here are some common ways the test suite can fail:</p>"},{"location":"contributing/#check-job-failed","title":"Check Job Failed","text":"<p>This job failing means there is either a code formatting issue or type-annotation issue. You can look at the job output to figure out why it's failed or within a shell run:</p> <pre><code>$ scripts/check\n</code></pre> <p>It may be worth it to run <code>$ scripts/lint</code> to attempt auto-formatting the code and if that job succeeds commit the changes.</p>"},{"location":"contributing/#docs-job-failed","title":"Docs Job Failed","text":"<p>This job failing means the documentation failed to build. This can happen for a variety of reasons like invalid markdown or missing configuration within <code>mkdocs.yml</code>.</p>"},{"location":"contributing/#python-3x-job-failed","title":"Python 3.X Job Failed","text":"<p>This job failing means the unit tests failed or not all code paths are covered by unit tests.</p> <p>If tests are failing you will see this message under the coverage report:</p> <p><code>=== 1 failed, 435 passed, 1 skipped, 1 xfailed in 11.09s ===</code></p> <p>If tests succeed but coverage doesn't reach our current threshold, you will see this message under the coverage report:</p> <p><code>FAIL Required test coverage of 100% not reached. Total coverage: 99.00%</code></p>"},{"location":"contributing/#releasing","title":"Releasing","text":"<p>This section is targeted at Starlette maintainers.</p> <p>Before releasing a new version, create a pull request that includes:</p> <ul> <li>An update to the changelog:<ul> <li>We follow the format from keepachangelog.</li> <li>Compare <code>master</code> with the tag of the latest release, and list all entries that are of interest to our users:<ul> <li>Things that must go in the changelog: added, changed, deprecated or removed features, and bug fixes.</li> <li>Things that should not go in the changelog: changes to documentation, tests or tooling.</li> <li>Try sorting entries in descending order of impact / importance.</li> <li>Keep it concise and to-the-point. \ud83c\udfaf</li> </ul> </li> </ul> </li> <li>A version bump: see <code>__version__.py</code>.</li> </ul> <p>For an example, see #1600.</p> <p>Once the release PR is merged, create a new release including:</p> <ul> <li>Tag version like <code>0.13.3</code>.</li> <li>Release title <code>Version 0.13.3</code></li> <li>Description copied from the changelog.</li> </ul> <p>Once created this release will be automatically uploaded to PyPI.</p> <p>If something goes wrong with the PyPI job the release can be published using the <code>scripts/publish</code> script.</p>"},{"location":"database/","title":"Database","text":"<p>Starlette is not strictly tied to any particular database implementation.</p> <p>You can use it with an asynchronous ORM, such as GINO, or use regular non-async endpoints, and integrate with SQLAlchemy.</p> <p>In this documentation we'll demonstrate how to integrate against the <code>databases</code> package, which provides SQLAlchemy core support against a range of different database drivers.</p> <p>Here's a complete example, that includes table definitions, configuring a <code>database.Database</code> instance, and a couple of endpoints that interact with the database.</p> .env<pre><code>DATABASE_URL=sqlite:///test.db\n</code></pre> app.py<pre><code>import contextlib\n\nimport databases\nimport sqlalchemy\nfrom starlette.applications import Starlette\nfrom starlette.config import Config\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\n\n# Configuration from environment variables or '.env' file.\nconfig = Config('.env')\nDATABASE_URL = config('DATABASE_URL')\n\n\n# Database table definitions.\nmetadata = sqlalchemy.MetaData()\n\nnotes = sqlalchemy.Table(\n    \"notes\",\n    metadata,\n    sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True),\n    sqlalchemy.Column(\"text\", sqlalchemy.String),\n    sqlalchemy.Column(\"completed\", sqlalchemy.Boolean),\n)\n\ndatabase = databases.Database(DATABASE_URL)\n\n@contextlib.asynccontextmanager\nasync def lifespan(app):\n    await database.connect()\n    yield\n    await database.disconnect()\n\n# Main application code.\nasync def list_notes(request):\n    query = notes.select()\n    results = await database.fetch_all(query)\n    content = [\n        {\n            \"text\": result[\"text\"],\n            \"completed\": result[\"completed\"]\n        }\n        for result in results\n    ]\n    return JSONResponse(content)\n\nasync def add_note(request):\n    data = await request.json()\n    query = notes.insert().values(\n       text=data[\"text\"],\n       completed=data[\"completed\"]\n    )\n    await database.execute(query)\n    return JSONResponse({\n        \"text\": data[\"text\"],\n        \"completed\": data[\"completed\"]\n    })\n\nroutes = [\n    Route(\"/notes\", endpoint=list_notes, methods=[\"GET\"]),\n    Route(\"/notes\", endpoint=add_note, methods=[\"POST\"]),\n]\n\napp = Starlette(\n    routes=routes,\n    lifespan=lifespan,\n)\n</code></pre> <p>Finally, you will need to create the database tables. It is recommended to use Alembic, which we briefly go over in Migrations</p>"},{"location":"database/#queries","title":"Queries","text":"<p>Queries may be made with as SQLAlchemy Core queries.</p> <p>The following methods are supported:</p> <ul> <li><code>rows = await database.fetch_all(query)</code></li> <li><code>row = await database.fetch_one(query)</code></li> <li><code>async for row in database.iterate(query)</code></li> <li><code>await database.execute(query)</code></li> <li><code>await database.execute_many(query)</code></li> </ul>"},{"location":"database/#transactions","title":"Transactions","text":"<p>Database transactions are available either as a decorator, as a context manager, or as a low-level API.</p> <p>Using a decorator on an endpoint:</p> <pre><code>@database.transaction()\nasync def populate_note(request):\n    # This database insert occurs within a transaction.\n    # It will be rolled back by the `RuntimeError`.\n    query = notes.insert().values(text=\"you won't see me\", completed=True)\n    await database.execute(query)\n    raise RuntimeError()\n</code></pre> <p>Using a context manager:</p> <pre><code>async def populate_note(request):\n    async with database.transaction():\n        # This database insert occurs within a transaction.\n        # It will be rolled back by the `RuntimeError`.\n        query = notes.insert().values(text=\"you won't see me\", completed=True)\n        await request.database.execute(query)\n        raise RuntimeError()\n</code></pre> <p>Using the low-level API:</p> <pre><code>async def populate_note(request):\n    transaction = await database.transaction()\n    try:\n        # This database insert occurs within a transaction.\n        # It will be rolled back by the `RuntimeError`.\n        query = notes.insert().values(text=\"you won't see me\", completed=True)\n        await database.execute(query)\n        raise RuntimeError()\n    except:\n        await transaction.rollback()\n        raise\n    else:\n        await transaction.commit()\n</code></pre>"},{"location":"database/#test-isolation","title":"Test isolation","text":"<p>There are a few things that we want to ensure when running tests against a service that uses a database. Our requirements should be:</p> <ul> <li>Use a separate database for testing.</li> <li>Create a new test database every time we run the tests.</li> <li>Ensure that the database state is isolated between each test case.</li> </ul> <p>Here's how we need to structure our application and tests in order to meet those requirements:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.config import Config\nimport databases\n\nconfig = Config(\".env\")\n\nTESTING = config('TESTING', cast=bool, default=False)\nDATABASE_URL = config('DATABASE_URL', cast=databases.DatabaseURL)\nTEST_DATABASE_URL = DATABASE_URL.replace(database='test_' + DATABASE_URL.database)\n\n# Use 'force_rollback' during testing, to ensure we do not persist database changes\n# between each test case.\nif TESTING:\n    database = databases.Database(TEST_DATABASE_URL, force_rollback=True)\nelse:\n    database = databases.Database(DATABASE_URL)\n</code></pre> <p>We still need to set <code>TESTING</code> during a test run, and setup the test database. Assuming we're using <code>py.test</code>, here's how our <code>conftest.py</code> might look:</p> <pre><code>import pytest\nfrom starlette.config import environ\nfrom starlette.testclient import TestClient\nfrom sqlalchemy import create_engine\nfrom sqlalchemy_utils import database_exists, create_database, drop_database\n\n# This sets `os.environ`, but provides some additional protection.\n# If we placed it below the application import, it would raise an error\n# informing us that 'TESTING' had already been read from the environment.\nenviron['TESTING'] = 'True'\n\nimport app\n\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef create_test_database():\n  \"\"\"\n  Create a clean database on every test case.\n  For safety, we should abort if a database already exists.\n\n  We use the `sqlalchemy_utils` package here for a few helpers in consistently\n  creating and dropping the database.\n  \"\"\"\n  url = str(app.TEST_DATABASE_URL)\n  engine = create_engine(url)\n  assert not database_exists(url), 'Test database already exists. Aborting tests.'\n  create_database(url)             # Create the test database.\n  metadata.create_all(engine)      # Create the tables.\n  yield                            # Run the tests.\n  drop_database(url)               # Drop the test database.\n\n\n@pytest.fixture()\ndef client():\n    \"\"\"\n    When using the 'client' fixture in test cases, we'll get full database\n    rollbacks between test cases:\n\n    def test_homepage(client):\n        url = app.url_path_for('homepage')\n        response = client.get(url)\n        assert response.status_code == 200\n    \"\"\"\n    with TestClient(app) as client:\n        yield client\n</code></pre>"},{"location":"database/#migrations","title":"Migrations","text":"<p>You'll almost certainly need to be using database migrations in order to manage incremental changes to the database. For this we'd strongly recommend Alembic, which is written by the author of SQLAlchemy.</p> <pre><code>$ pip install alembic\n$ alembic init migrations\n</code></pre> <p>Now, you'll want to set things up so that Alembic references the configured DATABASE_URL, and uses your table metadata.</p> <p>In <code>alembic.ini</code> remove the following line:</p> <pre><code>sqlalchemy.url = driver://user:pass@localhost/dbname\n</code></pre> <p>In <code>migrations/env.py</code>, you need to set the <code>'sqlalchemy.url'</code> configuration key, and the <code>target_metadata</code> variable. You'll want something like this:</p> <pre><code># The Alembic Config object.\nconfig = context.config\n\n# Configure Alembic to use our DATABASE_URL and our table definitions...\nimport app\nconfig.set_main_option('sqlalchemy.url', str(app.DATABASE_URL))\ntarget_metadata = app.metadata\n\n...\n</code></pre> <p>Then, using our notes example above, create an initial revision:</p> <pre><code>alembic revision -m \"Create notes table\"\n</code></pre> <p>And populate the new file (within <code>migrations/versions</code>) with the necessary directives:</p> <pre><code>def upgrade():\n    op.create_table(\n      'notes',\n      sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True),\n      sqlalchemy.Column(\"text\", sqlalchemy.String),\n      sqlalchemy.Column(\"completed\", sqlalchemy.Boolean),\n    )\n\ndef downgrade():\n    op.drop_table('notes')\n</code></pre> <p>And run your first migration. Our notes app can now run!</p> <pre><code>alembic upgrade head\n</code></pre> <p>Running migrations during testing</p> <p>It is good practice to ensure that your test suite runs the database migrations every time it creates the test database. This will help catch any issues in your migration scripts, and will help ensure that the tests are running against a database that's in a consistent state with your live database.</p> <p>We can adjust the <code>create_test_database</code> fixture slightly:</p> <pre><code>from alembic import command\nfrom alembic.config import Config\nimport app\n\n...\n\n@pytest.fixture(scope=\"session\", autouse=True)\ndef create_test_database():\n    url = str(app.DATABASE_URL)\n    engine = create_engine(url)\n    assert not database_exists(url), 'Test database already exists. Aborting tests.'\n    create_database(url)             # Create the test database.\n    config = Config(\"alembic.ini\")   # Run the migrations.\n    command.upgrade(config, \"head\")\n    yield                            # Run the tests.\n    drop_database(url)               # Drop the test database.\n</code></pre>"},{"location":"endpoints/","title":"Endpoints","text":"<p>Starlette includes the classes <code>HTTPEndpoint</code> and <code>WebSocketEndpoint</code> that provide a class-based view pattern for handling HTTP method dispatching and WebSocket sessions.</p>"},{"location":"endpoints/#httpendpoint","title":"HTTPEndpoint","text":"<p>The <code>HTTPEndpoint</code> class can be used as an ASGI application:</p> <pre><code>from starlette.responses import PlainTextResponse\nfrom starlette.endpoints import HTTPEndpoint\n\n\nclass App(HTTPEndpoint):\n    async def get(self, request):\n        return PlainTextResponse(f\"Hello, world!\")\n</code></pre> <p>If you're using a Starlette application instance to handle routing, you can dispatch to an <code>HTTPEndpoint</code> class. Make sure to dispatch to the class itself, rather than to an instance of the class:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.responses import PlainTextResponse\nfrom starlette.endpoints import HTTPEndpoint\nfrom starlette.routing import Route\n\n\nclass Homepage(HTTPEndpoint):\n    async def get(self, request):\n        return PlainTextResponse(f\"Hello, world!\")\n\n\nclass User(HTTPEndpoint):\n    async def get(self, request):\n        username = request.path_params['username']\n        return PlainTextResponse(f\"Hello, {username}\")\n\nroutes = [\n    Route(\"/\", Homepage),\n    Route(\"/{username}\", User)\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>HTTP endpoint classes will respond with \"405 Method not allowed\" responses for any request methods which do not map to a corresponding handler.</p>"},{"location":"endpoints/#websocketendpoint","title":"WebSocketEndpoint","text":"<p>The <code>WebSocketEndpoint</code> class is an ASGI application that presents a wrapper around the functionality of a <code>WebSocket</code> instance.</p> <p>The ASGI connection scope is accessible on the endpoint instance via <code>.scope</code> and has an attribute <code>encoding</code> which may optionally be set, in order to validate the expected websocket data in the <code>on_receive</code> method.</p> <p>The encoding types are:</p> <ul> <li><code>'json'</code></li> <li><code>'bytes'</code></li> <li><code>'text'</code></li> </ul> <p>There are three overridable methods for handling specific ASGI websocket message types:</p> <ul> <li><code>async def on_connect(websocket, **kwargs)</code></li> <li><code>async def on_receive(websocket, data)</code></li> <li><code>async def on_disconnect(websocket, close_code)</code></li> </ul> <pre><code>from starlette.endpoints import WebSocketEndpoint\n\n\nclass App(WebSocketEndpoint):\n    encoding = 'bytes'\n\n    async def on_connect(self, websocket):\n        await websocket.accept()\n\n    async def on_receive(self, websocket, data):\n        await websocket.send_bytes(b\"Message: \" + data)\n\n    async def on_disconnect(self, websocket, close_code):\n        pass\n</code></pre> <p>The <code>WebSocketEndpoint</code> can also be used with the <code>Starlette</code> application class:</p> <pre><code>import uvicorn\nfrom starlette.applications import Starlette\nfrom starlette.endpoints import WebSocketEndpoint, HTTPEndpoint\nfrom starlette.responses import HTMLResponse\nfrom starlette.routing import Route, WebSocketRoute\n\n\nhtml = \"\"\"\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Chat&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;WebSocket Chat&lt;/h1&gt;\n        &lt;form action=\"\" onsubmit=\"sendMessage(event)\"&gt;\n            &lt;input type=\"text\" id=\"messageText\" autocomplete=\"off\"/&gt;\n            &lt;button&gt;Send&lt;/button&gt;\n        &lt;/form&gt;\n        &lt;ul id='messages'&gt;\n        &lt;/ul&gt;\n        &lt;script&gt;\n            var ws = new WebSocket(\"ws://localhost:8000/ws\");\n            ws.onmessage = function(event) {\n                var messages = document.getElementById('messages')\n                var message = document.createElement('li')\n                var content = document.createTextNode(event.data)\n                message.appendChild(content)\n                messages.appendChild(message)\n            };\n            function sendMessage(event) {\n                var input = document.getElementById(\"messageText\")\n                ws.send(input.value)\n                input.value = ''\n                event.preventDefault()\n            }\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n\nclass Homepage(HTTPEndpoint):\n    async def get(self, request):\n        return HTMLResponse(html)\n\nclass Echo(WebSocketEndpoint):\n    encoding = \"text\"\n\n    async def on_receive(self, websocket, data):\n        await websocket.send_text(f\"Message text was: {data}\")\n\nroutes = [\n    Route(\"/\", Homepage),\n    WebSocketRoute(\"/ws\", Echo)\n]\n\napp = Starlette(routes=routes)\n</code></pre>"},{"location":"exceptions/","title":"Exceptions","text":"<p>Starlette allows you to install custom exception handlers to deal with how you return responses when errors or handled exceptions occur.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.exceptions import HTTPException\nfrom starlette.requests import Request\nfrom starlette.responses import HTMLResponse\n\n\nHTML_404_PAGE = ...\nHTML_500_PAGE = ...\n\n\nasync def not_found(request: Request, exc: HTTPException):\n    return HTMLResponse(content=HTML_404_PAGE, status_code=exc.status_code)\n\nasync def server_error(request: Request, exc: HTTPException):\n    return HTMLResponse(content=HTML_500_PAGE, status_code=exc.status_code)\n\n\nexception_handlers = {\n    404: not_found,\n    500: server_error\n}\n\napp = Starlette(routes=routes, exception_handlers=exception_handlers)\n</code></pre> <p>If <code>debug</code> is enabled and an error occurs, then instead of using the installed 500 handler, Starlette will respond with a traceback response.</p> <pre><code>app = Starlette(debug=True, routes=routes, exception_handlers=exception_handlers)\n</code></pre> <p>As well as registering handlers for specific status codes, you can also register handlers for classes of exceptions.</p> <p>In particular you might want to override how the built-in <code>HTTPException</code> class is handled. For example, to use JSON style responses:</p> <pre><code>async def http_exception(request: Request, exc: HTTPException):\n    return JSONResponse({\"detail\": exc.detail}, status_code=exc.status_code)\n\nexception_handlers = {\n    HTTPException: http_exception\n}\n</code></pre> <p>The <code>HTTPException</code> is also equipped with the <code>headers</code> argument. Which allows the propagation of the headers to the response class:</p> <pre><code>async def http_exception(request: Request, exc: HTTPException):\n    return JSONResponse(\n        {\"detail\": exc.detail},\n        status_code=exc.status_code,\n        headers=exc.headers\n    )\n</code></pre> <p>You might also want to override how <code>WebSocketException</code> is handled:</p> <pre><code>async def websocket_exception(websocket: WebSocket, exc: WebSocketException):\n    await websocket.close(code=1008)\n\nexception_handlers = {\n    WebSocketException: websocket_exception\n}\n</code></pre>"},{"location":"exceptions/#errors-and-handled-exceptions","title":"Errors and handled exceptions","text":"<p>It is important to differentiate between handled exceptions and errors.</p> <p>Handled exceptions do not represent error cases. They are coerced into appropriate HTTP responses, which are then sent through the standard middleware stack. By default the <code>HTTPException</code> class is used to manage any handled exceptions.</p> <p>Errors are any other exception that occurs within the application. These cases should bubble through the entire middleware stack as exceptions. Any error logging middleware should ensure that it re-raises the exception all the way up to the server.</p> <p>In practical terms, the error handled used is <code>exception_handler[500]</code> or <code>exception_handler[Exception]</code>. Both keys <code>500</code> and <code>Exception</code> can be used. See below:</p> <pre><code>async def handle_error(request: Request, exc: HTTPException):\n    # Perform some logic\n    return JSONResponse({\"detail\": exc.detail}, status_code=exc.status_code)\n\nexception_handlers = {\n    Exception: handle_error  # or \"500: handle_error\"\n}\n</code></pre> <p>It's important to notice that in case a <code>BackgroundTask</code> raises an exception, it will be handled by the <code>handle_error</code> function, but at that point, the response was already sent. In other words, the response created by <code>handle_error</code> will be discarded. In case the error happens before the response was sent, then it will use the response object - in the above example, the returned <code>JSONResponse</code>.</p> <p>In order to deal with this behaviour correctly, the middleware stack of a <code>Starlette</code> application is configured like this:</p> <ul> <li><code>ServerErrorMiddleware</code> - Returns 500 responses when server errors occur.</li> <li>Installed middleware</li> <li><code>ExceptionMiddleware</code> - Deals with handled exceptions, and returns responses.</li> <li>Router</li> <li>Endpoints</li> </ul>"},{"location":"exceptions/#httpexception","title":"HTTPException","text":"<p>The <code>HTTPException</code> class provides a base class that you can use for any handled exceptions. The <code>ExceptionMiddleware</code> implementation defaults to returning plain-text HTTP responses for any <code>HTTPException</code>.</p> <ul> <li><code>HTTPException(status_code, detail=None, headers=None)</code></li> </ul> <p>You should only raise <code>HTTPException</code> inside routing or endpoints. Middleware classes should instead just return appropriate responses directly.</p> <p>You can use an <code>HTTPException</code> on a WebSocket endpoint. In case it's raised before <code>websocket.accept()</code> the connection is not upgraded to a WebSocket connection, and the proper HTTP response is returned.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.exceptions import HTTPException\nfrom starlette.routing import WebSocketRoute\nfrom starlette.websockets import WebSocket\n\n\nasync def websocket_endpoint(websocket: WebSocket):\n    raise HTTPException(status_code=400, detail=\"Bad request\")\n\n\napp = Starlette(routes=[WebSocketRoute(\"/ws\", websocket_endpoint)])\n</code></pre>"},{"location":"exceptions/#websocketexception","title":"WebSocketException","text":"<p>You can use the <code>WebSocketException</code> class to raise errors inside of WebSocket endpoints.</p> <ul> <li><code>WebSocketException(code=1008, reason=None)</code></li> </ul> <p>You can set any code valid as defined in the specification.</p>"},{"location":"graphql/","title":"GraphQL","text":"<p>GraphQL support in Starlette was deprecated in version 0.15.0, and removed in version 0.17.0.</p> <p>Although GraphQL support is no longer built in to Starlette, you can still use GraphQL with Starlette via 3rd party libraries. These libraries all have Starlette-specific guides to help you do just that:</p> <ul> <li>Ariadne</li> <li><code>starlette-graphene3</code></li> <li>Strawberry</li> <li><code>tartiflette-asgi</code></li> </ul>"},{"location":"lifespan/","title":"Lifespan","text":"<p>Starlette applications can register a lifespan handler for dealing with code that needs to run before the application starts up, or when the application is shutting down.</p> <pre><code>import contextlib\n\nfrom starlette.applications import Starlette\n\n\n@contextlib.asynccontextmanager\nasync def lifespan(app):\n    async with some_async_resource():\n        print(\"Run at startup!\")\n        yield\n        print(\"Run on shutdown!\")\n\n\nroutes = [\n    ...\n]\n\napp = Starlette(routes=routes, lifespan=lifespan)\n</code></pre> <p>Starlette will not start serving any incoming requests until the lifespan has been run.</p> <p>The lifespan teardown will run once all connections have been closed, and any in-process background tasks have completed.</p> <p>Consider using <code>anyio.create_task_group()</code> for managing asynchronous tasks.</p>"},{"location":"lifespan/#lifespan-state","title":"Lifespan State","text":"<p>The lifespan has the concept of <code>state</code>, which is a dictionary that can be used to share the objects between the lifespan, and the requests.</p> <pre><code>import contextlib\nfrom typing import AsyncIterator, TypedDict\n\nimport httpx\nfrom starlette.applications import Starlette\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\n\n\nclass State(TypedDict):\n    http_client: httpx.AsyncClient\n\n\n@contextlib.asynccontextmanager\nasync def lifespan(app: Starlette) -&gt; AsyncIterator[State]:\n    async with httpx.AsyncClient() as client:\n        yield {\"http_client\": client}\n\n\nasync def homepage(request: Request) -&gt; PlainTextResponse:\n    client = request.state.http_client\n    response = await client.get(\"https://www.example.com\")\n    return PlainTextResponse(response.text)\n\n\napp = Starlette(\n    lifespan=lifespan,\n    routes=[Route(\"/\", homepage)]\n)\n</code></pre> <p>The <code>state</code> received on the requests is a shallow copy of the state received on the lifespan handler.</p>"},{"location":"lifespan/#running-lifespan-in-tests","title":"Running lifespan in tests","text":"<p>You should use <code>TestClient</code> as a context manager, to ensure that the lifespan is called.</p> <pre><code>from example import app\nfrom starlette.testclient import TestClient\n\n\ndef test_homepage():\n    with TestClient(app) as client:\n        # Application's lifespan is called on entering the block.\n        response = client.get(\"/\")\n        assert response.status_code == 200\n\n    # And the lifespan's teardown is run when exiting the block.\n</code></pre>"},{"location":"middleware/","title":"Middleware","text":"<p>Starlette includes several middleware classes for adding behavior that is applied across your entire application. These are all implemented as standard ASGI middleware classes, and can be applied either to Starlette or to any other ASGI application.</p>"},{"location":"middleware/#using-middleware","title":"Using middleware","text":"<p>The Starlette application class allows you to include the ASGI middleware in a way that ensures that it remains wrapped by the exception handler.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.httpsredirect import HTTPSRedirectMiddleware\nfrom starlette.middleware.trustedhost import TrustedHostMiddleware\n\nroutes = ...\n\n# Ensure that all requests include an 'example.com' or\n# '*.example.com' host header, and strictly enforce https-only access.\nmiddleware = [\n    Middleware(\n        TrustedHostMiddleware,\n        allowed_hosts=['example.com', '*.example.com'],\n    ),\n    Middleware(HTTPSRedirectMiddleware)\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre> <p>Every Starlette application automatically includes two pieces of middleware by default:</p> <ul> <li><code>ServerErrorMiddleware</code> - Ensures that application exceptions may return a custom 500 page, or display an application traceback in DEBUG mode. This is always the outermost middleware layer.</li> <li><code>ExceptionMiddleware</code> - Adds exception handlers, so that particular types of expected exception cases can be associated with handler functions. For example raising <code>HTTPException(status_code=404)</code> within an endpoint will end up rendering a custom 404 page.</li> </ul> <p>Middleware is evaluated from top-to-bottom, so the flow of execution in our example application would look like this:</p> <ul> <li>Middleware<ul> <li><code>ServerErrorMiddleware</code></li> <li><code>TrustedHostMiddleware</code></li> <li><code>HTTPSRedirectMiddleware</code></li> <li><code>ExceptionMiddleware</code></li> </ul> </li> <li>Routing</li> <li>Endpoint</li> </ul> <p>The following middleware implementations are available in the Starlette package:</p>"},{"location":"middleware/#corsmiddleware","title":"CORSMiddleware","text":"<p>Adds appropriate CORS headers to outgoing responses in order to allow cross-origin requests from browsers.</p> <p>The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.cors import CORSMiddleware\n\nroutes = ...\n\nmiddleware = [\n    Middleware(CORSMiddleware, allow_origins=['*'])\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre> <p>The following arguments are supported:</p> <ul> <li><code>allow_origins</code> - A list of origins that should be permitted to make cross-origin requests. eg. <code>['https://example.org', 'https://www.example.org']</code>. You can use <code>['*']</code> to allow any origin.</li> <li><code>allow_origin_regex</code> - A regex string to match against origins that should be permitted to make cross-origin requests. eg. <code>'https://.*\\.example\\.org'</code>.</li> <li><code>allow_methods</code> - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to <code>['GET']</code>. You can use <code>['*']</code> to allow all standard methods.</li> <li><code>allow_headers</code> - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to <code>[]</code>. You can use <code>['*']</code> to allow all headers. The <code>Accept</code>, <code>Accept-Language</code>, <code>Content-Language</code> and <code>Content-Type</code> headers are always allowed for CORS requests.</li> <li><code>allow_credentials</code> - Indicate that cookies should be supported for cross-origin requests. Defaults to <code>False</code>. Also, <code>allow_origins</code>, <code>allow_methods</code> and <code>allow_headers</code> cannot be set to <code>['*']</code> for credentials to be allowed, all of them must be explicitly specified.</li> <li><code>expose_headers</code> - Indicate any response headers that should be made accessible to the browser. Defaults to <code>[]</code>.</li> <li><code>max_age</code> - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to <code>600</code>.</li> </ul> <p>The middleware responds to two particular types of HTTP request...</p>"},{"location":"middleware/#cors-preflight-requests","title":"CORS preflight requests","text":"<p>These are any <code>OPTIONS</code> request with <code>Origin</code> and <code>Access-Control-Request-Method</code> headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes.</p>"},{"location":"middleware/#simple-requests","title":"Simple requests","text":"<p>Any request with an <code>Origin</code> header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response.</p>"},{"location":"middleware/#corsmiddleware-global-enforcement","title":"CORSMiddleware Global Enforcement","text":"<p>When using CORSMiddleware with your Starlette application, it's important to ensure that CORS headers are applied even to error responses generated by unhandled exceptions. The recommended solution is to wrap the entire Starlette application with CORSMiddleware. This approach guarantees that even if an exception is caught by ServerErrorMiddleware (or other outer error-handling middleware), the response will still include the proper <code>Access-Control-Allow-Origin</code> header.</p> <p>For example, instead of adding CORSMiddleware as an inner <code>middleware</code> via the Starlette middleware parameter, you can wrap your application as follows:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware.cors import CORSMiddleware\n\nimport uvicorn\n\napp = Starlette()\napp = CORSMiddleware(app=app, allow_origins=[\"*\"])\n\n# ... your routes and middleware configuration ...\n\nif __name__ == '__main__':\n    uvicorn.run(\n        app,\n        host='0.0.0.0',\n        port=8000\n    )\n</code></pre>"},{"location":"middleware/#sessionmiddleware","title":"SessionMiddleware","text":"<p>Adds signed cookie-based HTTP sessions. Session information is readable but not modifiable.</p> <p>Access or modify the session data using the <code>request.session</code> dictionary interface.</p> <p>The following arguments are supported:</p> <ul> <li><code>secret_key</code> - Should be a random string.</li> <li><code>session_cookie</code> - Defaults to \"session\".</li> <li><code>max_age</code> - Session expiry time in seconds. Defaults to 2 weeks. If set to <code>None</code> then the cookie will last as long as the browser session.</li> <li><code>same_site</code> - SameSite flag prevents the browser from sending session cookie along with cross-site requests. Defaults to <code>'lax'</code>.</li> <li><code>path</code> - The path set for the session cookie. Defaults to <code>'/'</code>.</li> <li><code>https_only</code> - Indicate that Secure flag should be set (can be used with HTTPS only). Defaults to <code>False</code>.</li> <li><code>domain</code> - Domain of the cookie used to share cookie between subdomains or cross-domains. The browser defaults the domain to the same host that set the cookie, excluding subdomains (reference).</li> </ul> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.sessions import SessionMiddleware\n\nroutes = ...\n\nmiddleware = [\n    Middleware(SessionMiddleware, secret_key=..., https_only=True)\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre>"},{"location":"middleware/#httpsredirectmiddleware","title":"HTTPSRedirectMiddleware","text":"<p>Enforces that all incoming requests must either be <code>https</code> or <code>wss</code>. Any incoming requests to <code>http</code> or <code>ws</code> will be redirected to the secure scheme instead.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.httpsredirect import HTTPSRedirectMiddleware\n\nroutes = ...\n\nmiddleware = [\n    Middleware(HTTPSRedirectMiddleware)\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre> <p>There are no configuration options for this middleware class.</p>"},{"location":"middleware/#trustedhostmiddleware","title":"TrustedHostMiddleware","text":"<p>Enforces that all incoming requests have a correctly set <code>Host</code> header, in order to guard against HTTP Host Header attacks.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.trustedhost import TrustedHostMiddleware\n\nroutes = ...\n\nmiddleware = [\n    Middleware(TrustedHostMiddleware, allowed_hosts=['example.com', '*.example.com'])\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre> <p>The following arguments are supported:</p> <ul> <li><code>allowed_hosts</code> - A list of domain names that should be allowed as hostnames. Wildcard domains such as <code>*.example.com</code> are supported for matching subdomains. To allow any hostname either use <code>allowed_hosts=[\"*\"]</code> or omit the middleware.</li> <li><code>www_redirect</code> - If set to True, requests to non-www versions of the allowed hosts will be redirected to their www counterparts. Defaults to <code>True</code>.</li> </ul> <p>If an incoming request does not validate correctly then a 400 response will be sent.</p>"},{"location":"middleware/#gzipmiddleware","title":"GZipMiddleware","text":"<p>Handles GZip responses for any request that includes <code>\"gzip\"</code> in the <code>Accept-Encoding</code> header.</p> <p>The middleware will handle both standard and streaming responses.</p> Buffer on streaming responses <p>On streaming responses, the middleware will buffer the response before compressing it.</p> <p>The idea is that we don't want to compress every small chunk of data, as it would be inefficient. Instead, we buffer the response until it reaches a certain size, and then compress it.</p> <p>This may cause a delay in the response, as the middleware waits for the buffer to fill up before compressing it.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.gzip import GZipMiddleware\n\n\nroutes = ...\n\nmiddleware = [\n    Middleware(GZipMiddleware, minimum_size=1000, compresslevel=9)\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre> <p>The following arguments are supported:</p> <ul> <li><code>minimum_size</code> - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to <code>500</code>.</li> <li><code>compresslevel</code> - Used during GZip compression. It is an integer ranging from 1 to 9. Defaults to <code>9</code>. Lower value results in faster compression but larger file sizes, while higher value results in slower compression but smaller file sizes.</li> </ul> <p>The middleware won't GZip responses that already have either a <code>Content-Encoding</code> set, to prevent them from being encoded twice, or a <code>Content-Type</code> set to <code>text/event-stream</code>, to avoid compressing server-sent events.</p>"},{"location":"middleware/#basehttpmiddleware","title":"BaseHTTPMiddleware","text":"<p>An abstract class that allows you to write ASGI middleware against a request/response interface.</p>"},{"location":"middleware/#usage","title":"Usage","text":"<p>To implement a middleware class using <code>BaseHTTPMiddleware</code>, you must override the <code>async def dispatch(request, call_next)</code> method.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\n\nclass CustomHeaderMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        response = await call_next(request)\n        response.headers['Custom'] = 'Example'\n        return response\n\nroutes = ...\n\nmiddleware = [\n    Middleware(CustomHeaderMiddleware)\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre> <p>If you want to provide configuration options to the middleware class you should override the <code>__init__</code> method, ensuring that the first argument is <code>app</code>, and any remaining arguments are optional keyword arguments. Make sure to set the <code>app</code> attribute on the instance if you do this.</p> <pre><code>class CustomHeaderMiddleware(BaseHTTPMiddleware):\n    def __init__(self, app, header_value='Example'):\n        super().__init__(app)\n        self.header_value = header_value\n\n    async def dispatch(self, request, call_next):\n        response = await call_next(request)\n        response.headers['Custom'] = self.header_value\n        return response\n\n\nmiddleware = [\n    Middleware(CustomHeaderMiddleware, header_value='Customized')\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre> <p>Middleware classes should not modify their state outside of the <code>__init__</code> method. Instead you should keep any state local to the <code>dispatch</code> method, or pass it around explicitly, rather than mutating the middleware instance.</p>"},{"location":"middleware/#limitations","title":"Limitations","text":"<p>Currently, the <code>BaseHTTPMiddleware</code> has some known limitations:</p> <ul> <li>Using <code>BaseHTTPMiddleware</code> will prevent changes to <code>contextvars.ContextVar</code>s from propagating upwards. That is, if you set a value for a <code>ContextVar</code> in your endpoint and try to read it from a middleware you will find that the value is not the same value you set in your endpoint (see this test for an example of this behavior).</li> </ul> <p>To overcome these limitations, use pure ASGI middleware, as shown below.</p>"},{"location":"middleware/#pure-asgi-middleware","title":"Pure ASGI Middleware","text":"<p>The ASGI spec makes it possible to implement ASGI middleware using the ASGI interface directly, as a chain of ASGI applications that call into the next one. In fact, this is how middleware classes shipped with Starlette are implemented.</p> <p>This lower-level approach provides greater control over behavior and enhanced interoperability across frameworks and servers. It also overcomes the limitations of <code>BaseHTTPMiddleware</code>.</p>"},{"location":"middleware/#writing-pure-asgi-middleware","title":"Writing pure ASGI middleware","text":"<p>The most common way to create an ASGI middleware is with a class.</p> <pre><code>class ASGIMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        await self.app(scope, receive, send)\n</code></pre> <p>The middleware above is the most basic ASGI middleware. It receives a parent ASGI application as an argument for its constructor, and implements an <code>async __call__</code> method which calls into that parent application.</p> <p>Some implementations such as <code>asgi-cors</code> use an alternative style, using functions:</p> <pre><code>import functools\n\ndef asgi_middleware():\n    def asgi_decorator(app):\n\n        @functools.wraps(app)\n        async def wrapped_app(scope, receive, send):\n            await app(scope, receive, send)\n\n        return wrapped_app\n\n    return asgi_decorator\n</code></pre> <p>In any case, ASGI middleware must be callables that accept three arguments: <code>scope</code>, <code>receive</code>, and <code>send</code>.</p> <ul> <li><code>scope</code> is a dict holding information about the connection, where <code>scope[\"type\"]</code> may be:<ul> <li><code>\"http\"</code>: for HTTP requests.</li> <li><code>\"websocket\"</code>: for WebSocket connections.</li> <li><code>\"lifespan\"</code>: for ASGI lifespan messages.</li> </ul> </li> <li><code>receive</code> and <code>send</code> can be used to exchange ASGI event messages with the ASGI server \u2014 more on this below. The type and contents of these messages depend on the scope type. Learn more in the ASGI specification.</li> </ul>"},{"location":"middleware/#using-pure-asgi-middleware","title":"Using pure ASGI middleware","text":"<p>Pure ASGI middleware can be used like any other middleware:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\n\nfrom .middleware import ASGIMiddleware\n\nroutes = ...\n\nmiddleware = [\n    Middleware(ASGIMiddleware),\n]\n\napp = Starlette(..., middleware=middleware)\n</code></pre> <p>See also Using middleware.</p>"},{"location":"middleware/#type-annotations","title":"Type annotations","text":"<p>There are two ways of annotating a middleware: using Starlette itself or <code>asgiref</code>.</p> <ul> <li>Using Starlette: for most common use cases.</li> </ul> <pre><code>from starlette.types import ASGIApp, Message, Scope, Receive, Send\n\n\nclass ASGIMiddleware:\n    def __init__(self, app: ASGIApp) -&gt; None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        async def send_wrapper(message: Message) -&gt; None:\n            # ... Do something\n            await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n</code></pre> <ul> <li>Using <code>asgiref</code>: for more rigorous type hinting.</li> </ul> <pre><code>from asgiref.typing import ASGI3Application, ASGIReceiveCallable, ASGISendCallable, Scope\nfrom asgiref.typing import ASGIReceiveEvent, ASGISendEvent\n\n\nclass ASGIMiddleware:\n    def __init__(self, app: ASGI3Application) -&gt; None:\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -&gt; None:\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        async def send_wrapper(message: ASGISendEvent) -&gt; None:\n            # ... Do something\n            await send(message)\n\n        return await self.app(scope, receive, send_wrapper)\n</code></pre>"},{"location":"middleware/#common-patterns","title":"Common patterns","text":""},{"location":"middleware/#processing-certain-requests-only","title":"Processing certain requests only","text":"<p>ASGI middleware can apply specific behavior according to the contents of <code>scope</code>.</p> <p>For example, to only process HTTP requests, write this...</p> <pre><code>class ASGIMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        ...  # Do something here!\n\n        await self.app(scope, receive, send)\n</code></pre> <p>Likewise, WebSocket-only middleware would guard on <code>scope[\"type\"] != \"websocket\"</code>.</p> <p>The middleware may also act differently based on the request method, URL, headers, etc.</p>"},{"location":"middleware/#reusing-starlette-components","title":"Reusing Starlette components","text":"<p>Starlette provides several data structures that accept the ASGI <code>scope</code>, <code>receive</code> and/or <code>send</code> arguments, allowing you to work at a higher level of abstraction. Such data structures include <code>Request</code>, <code>Headers</code>, <code>QueryParams</code>, <code>URL</code>, etc.</p> <p>For example, you can instantiate a <code>Request</code> to more easily inspect an HTTP request:</p> <pre><code>from starlette.requests import Request\n\nclass ASGIMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] == \"http\":\n            request = Request(scope)\n            ... # Use `request.method`, `request.url`, `request.headers`, etc.\n\n        await self.app(scope, receive, send)\n</code></pre> <p>You can also reuse responses, which are ASGI applications as well.</p>"},{"location":"middleware/#sending-eager-responses","title":"Sending eager responses","text":"<p>Inspecting the connection <code>scope</code> allows you to conditionally call into a different ASGI app. One use case might be sending a response without calling into the app.</p> <p>As an example, this middleware uses a dictionary to perform permanent redirects based on the requested path. This could be used to implement ongoing support of legacy URLs in case you need to refactor route URL patterns.</p> <pre><code>from starlette.datastructures import URL\nfrom starlette.responses import RedirectResponse\n\nclass RedirectsMiddleware:\n    def __init__(self, app, path_mapping: dict):\n        self.app = app\n        self.path_mapping = path_mapping\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        url = URL(scope=scope)\n\n        if url.path in self.path_mapping:\n            url = url.replace(path=self.path_mapping[url.path])\n            response = RedirectResponse(url, status_code=301)\n            await response(scope, receive, send)\n            return\n\n        await self.app(scope, receive, send)\n</code></pre> <p>Example usage would look like this:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\n\nroutes = ...\n\nredirections = {\n    \"/v1/resource/\": \"/v2/resource/\",\n    # ...\n}\n\nmiddleware = [\n    Middleware(RedirectsMiddleware, path_mapping=redirections),\n]\n\napp = Starlette(routes=routes, middleware=middleware)\n</code></pre>"},{"location":"middleware/#inspecting-or-modifying-the-request","title":"Inspecting or modifying the request","text":"<p>Request information can be accessed or changed by manipulating the <code>scope</code>. For a full example of this pattern, see Uvicorn's <code>ProxyHeadersMiddleware</code> which inspects and tweaks the <code>scope</code> when serving behind a frontend proxy.</p> <p>Besides, wrapping the <code>receive</code> ASGI callable allows you to access or modify the HTTP request body by manipulating <code>http.request</code> ASGI event messages.</p> <p>As an example, this middleware computes and logs the size of the incoming request body...</p> <pre><code>class LoggedRequestBodySizeMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        body_size = 0\n\n        async def receive_logging_request_body_size():\n            nonlocal body_size\n\n            message = await receive()\n            assert message[\"type\"] == \"http.request\"\n\n            body_size += len(message.get(\"body\", b\"\"))\n\n            if not message.get(\"more_body\", False):\n                print(f\"Size of request body was: {body_size} bytes\")\n\n            return message\n\n        await self.app(scope, receive_logging_request_body_size, send)\n</code></pre> <p>Likewise, WebSocket middleware may manipulate <code>websocket.receive</code> ASGI event messages to inspect or alter incoming WebSocket data.</p> <p>For an example that changes the HTTP request body, see <code>msgpack-asgi</code>.</p>"},{"location":"middleware/#inspecting-or-modifying-the-response","title":"Inspecting or modifying the response","text":"<p>Wrapping the <code>send</code> ASGI callable allows you to inspect or modify the HTTP response sent by the underlying application. To do so, react to <code>http.response.start</code> or <code>http.response.body</code> ASGI event messages.</p> <p>As an example, this middleware adds some fixed extra response headers:</p> <pre><code>from starlette.datastructures import MutableHeaders\n\nclass ExtraResponseHeadersMiddleware:\n    def __init__(self, app, headers):\n        self.app = app\n        self.headers = headers\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        async def send_with_extra_headers(message):\n            if message[\"type\"] == \"http.response.start\":\n                headers = MutableHeaders(scope=message)\n                for key, value in self.headers:\n                    headers.append(key, value)\n\n            await send(message)\n\n        await self.app(scope, receive, send_with_extra_headers)\n</code></pre> <p>See also <code>asgi-logger</code> for an example that inspects the HTTP response and logs a configurable HTTP access log line.</p> <p>Likewise, WebSocket middleware may manipulate <code>websocket.send</code> ASGI event messages to inspect or alter outgoing WebSocket data.</p> <p>Note that if you change the response body, you will need to update the response <code>Content-Length</code> header to match the new response body length. See <code>brotli-asgi</code> for a complete example.</p>"},{"location":"middleware/#passing-information-to-endpoints","title":"Passing information to endpoints","text":"<p>If you need to share information with the underlying app or endpoints, you may store it into the <code>scope</code> dictionary. Note that this is a convention -- for example, Starlette uses this to share routing information with endpoints -- but it is not part of the ASGI specification. If you do so, be sure to avoid conflicts by using keys that have low chances of being used by other middleware or applications.</p> <p>For example, when including the middleware below, endpoints would be able to access <code>request.scope[\"asgi_transaction_id\"]</code>.</p> <pre><code>import uuid\n\nclass TransactionIDMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        scope[\"asgi_transaction_id\"] = uuid.uuid4()\n        await self.app(scope, receive, send)\n</code></pre>"},{"location":"middleware/#cleanup-and-error-handling","title":"Cleanup and error handling","text":"<p>You can wrap the application in a <code>try/except/finally</code> block or a context manager to perform cleanup operations or do error handling.</p> <p>For example, the following middleware might collect metrics and process application exceptions...</p> <pre><code>import time\n\nclass MonitoringMiddleware:\n    def __init__(self, app):\n        self.app = app\n\n    async def __call__(self, scope, receive, send):\n        start = time.time()\n        try:\n            await self.app(scope, receive, send)\n        except Exception as exc:\n            ...  # Process the exception\n            raise\n        finally:\n            end = time.time()\n            elapsed = end - start\n            ...  # Submit `elapsed` as a metric to a monitoring backend\n</code></pre> <p>See also <code>timing-asgi</code> for a full example of this pattern.</p>"},{"location":"middleware/#gotchas","title":"Gotchas","text":""},{"location":"middleware/#asgi-middleware-should-be-stateless","title":"ASGI middleware should be stateless","text":"<p>Because ASGI is designed to handle concurrent requests, any connection-specific state should be scoped to the <code>__call__</code> implementation. Not doing so would typically lead to conflicting variable reads/writes across requests, and most likely bugs.</p> <p>As an example, this would conditionally replace the response body, if an <code>X-Mock</code> header is present in the response...</p> \u2705 Do\u274c Don't <pre><code>from starlette.datastructures import Headers\n\nclass MockResponseBodyMiddleware:\n    def __init__(self, app, content):\n        self.app = app\n        self.content = content\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        # A flag that we will turn `True` if the HTTP response\n        # has the 'X-Mock' header.\n        # \u2705: Scoped to this function.\n        should_mock = False\n\n        async def maybe_send_with_mock_content(message):\n            nonlocal should_mock\n\n            if message[\"type\"] == \"http.response.start\":\n                headers = Headers(raw=message[\"headers\"])\n                should_mock = headers.get(\"X-Mock\") == \"1\"\n                await send(message)\n\n            elif message[\"type\"] == \"http.response.body\":\n                if should_mock:\n                    message = {\"type\": \"http.response.body\", \"body\": self.content}\n                await send(message)\n\n        await self.app(scope, receive, maybe_send_with_mock_content)\n</code></pre> <pre><code>from starlette.datastructures import Headers\n\nclass MockResponseBodyMiddleware:\n    def __init__(self, app, content):\n        self.app = app\n        self.content = content\n        # \u274c: This variable would be read and written across requests!\n        self.should_mock = False\n\n    async def __call__(self, scope, receive, send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        async def maybe_send_with_mock_content(message):\n            if message[\"type\"] == \"http.response.start\":\n                headers = Headers(raw=message[\"headers\"])\n                self.should_mock = headers.get(\"X-Mock\") == \"1\"\n                await send(message)\n\n            elif message[\"type\"] == \"http.response.body\":\n                if self.should_mock:\n                    message = {\"type\": \"http.response.body\", \"body\": self.content}\n                await send(message)\n\n        await self.app(scope, receive, maybe_send_with_mock_content)\n</code></pre> <p>See also <code>GZipMiddleware</code> for a full example implementation that navigates this potential gotcha.</p>"},{"location":"middleware/#further-reading","title":"Further reading","text":"<p>This documentation should be enough to have a good basis on how to create an ASGI middleware.</p> <p>Nonetheless, there are great articles about the subject:</p> <ul> <li>Introduction to ASGI: Emergence of an Async Python Web Ecosystem</li> <li>How to write ASGI middleware</li> </ul>"},{"location":"middleware/#using-middleware-in-other-frameworks","title":"Using middleware in other frameworks","text":"<p>To wrap ASGI middleware around other ASGI applications, you should use the more general pattern of wrapping the application instance:</p> <pre><code>app = TrustedHostMiddleware(app, allowed_hosts=['example.com'])\n</code></pre> <p>You can do this with a Starlette application instance too, but it is preferable to use the <code>middleware=&lt;List of Middleware instances&gt;</code> style, as it will:</p> <ul> <li>Ensure that everything remains wrapped in a single outermost <code>ServerErrorMiddleware</code>.</li> <li>Preserves the top-level <code>app</code> instance.</li> </ul>"},{"location":"middleware/#applying-middleware-to-groups-of-routes","title":"Applying middleware to groups of routes","text":"<p>Middleware can also be added to <code>Mount</code> instances, which allows you to apply middleware to a group of routes or a sub-application:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.gzip import GZipMiddleware\nfrom starlette.routing import Mount, Route\n\n\nroutes = [\n    Mount(\n        \"/\",\n        routes=[\n            Route(\n                \"/example\",\n                endpoint=...,\n            )\n        ],\n        middleware=[Middleware(GZipMiddleware)]\n    )\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>Note that middleware used in this way is not wrapped in exception handling middleware like the middleware applied to the <code>Starlette</code> application is. This is often not a problem because it only applies to middleware that inspect or modify the <code>Response</code>, and even then you probably don't want to apply this logic to error responses. If you do want to apply the middleware logic to error responses only on some routes you have a couple of options:</p> <ul> <li>Add an <code>ExceptionMiddleware</code> onto the <code>Mount</code></li> <li>Add a <code>try/except</code> block to your middleware and return an error response from there</li> <li>Split up marking and processing into two middlewares, one that gets put on <code>Mount</code> which marks the response as needing processing (for example by setting <code>scope[\"log-response\"] = True</code>) and another applied to the <code>Starlette</code> application that does the heavy lifting.</li> </ul> <p>The <code>Route</code>/<code>WebSocket</code> class also accepts a <code>middleware</code> argument, which allows you to apply middleware to a single route:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.gzip import GZipMiddleware\nfrom starlette.routing import Route\n\n\nroutes = [\n    Route(\n        \"/example\",\n        endpoint=...,\n        middleware=[Middleware(GZipMiddleware)]\n    )\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>You can also apply middleware to the <code>Router</code> class, which allows you to apply middleware to a group of routes:</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware import Middleware\nfrom starlette.middleware.gzip import GZipMiddleware\nfrom starlette.routing import Route, Router\n\n\nroutes = [\n    Route(\"/example\", endpoint=...),\n    Route(\"/another\", endpoint=...),\n]\n\nrouter = Router(routes=routes, middleware=[Middleware(GZipMiddleware)])\n</code></pre>"},{"location":"middleware/#third-party-middleware","title":"Third party middleware","text":""},{"location":"middleware/#asgi-auth-github","title":"asgi-auth-github","text":"<p>This middleware adds authentication to any ASGI application, requiring users to sign in using their GitHub account (via OAuth). Access can be restricted to specific users or to members of specific GitHub organizations or teams.</p>"},{"location":"middleware/#asgi-csrf","title":"asgi-csrf","text":"<p>Middleware for protecting against CSRF attacks. This middleware implements the Double Submit Cookie pattern, where a cookie is set, then it is compared to a csrftoken hidden form field or an <code>x-csrftoken</code> HTTP header.</p>"},{"location":"middleware/#authlibmiddleware","title":"AuthlibMiddleware","text":"<p>A drop-in replacement for Starlette session middleware, using authlib's jwt module.</p>"},{"location":"middleware/#bugsnagmiddleware","title":"BugsnagMiddleware","text":"<p>A middleware class for logging exceptions to Bugsnag.</p>"},{"location":"middleware/#csrfmiddleware","title":"CSRFMiddleware","text":"<p>Middleware for protecting against CSRF attacks. This middleware implements the Double Submit Cookie pattern, where a cookie is set, then it is compared to an <code>x-csrftoken</code> HTTP header.</p>"},{"location":"middleware/#earlydatamiddleware","title":"EarlyDataMiddleware","text":"<p>Middleware and decorator for detecting and denying TLSv1.3 early data requests.</p>"},{"location":"middleware/#prometheusmiddleware","title":"PrometheusMiddleware","text":"<p>A middleware class for capturing Prometheus metrics related to requests and responses, including in progress requests, timing...</p>"},{"location":"middleware/#proxyheadersmiddleware","title":"ProxyHeadersMiddleware","text":"<p>Uvicorn includes a middleware class for determining the client IP address, when proxy servers are being used, based on the <code>X-Forwarded-Proto</code> and <code>X-Forwarded-For</code> headers. For more complex proxy configurations, you might want to adapt this middleware.</p>"},{"location":"middleware/#ratelimitmiddleware","title":"RateLimitMiddleware","text":"<p>A rate limit middleware. Regular expression matches url; flexible rules; highly customizable. Very easy to use.</p>"},{"location":"middleware/#requestidmiddleware","title":"RequestIdMiddleware","text":"<p>A middleware class for reading/generating request IDs and attaching them to application logs.</p>"},{"location":"middleware/#rollbarmiddleware","title":"RollbarMiddleware","text":"<p>A middleware class for logging exceptions, errors, and log messages to Rollbar.</p>"},{"location":"middleware/#starletteopentracing","title":"StarletteOpentracing","text":"<p>A middleware class that emits tracing info to OpenTracing.io compatible tracers and can be used to profile and monitor distributed applications.</p>"},{"location":"middleware/#securecookiesmiddleware","title":"SecureCookiesMiddleware","text":"<p>Customizable middleware for adding automatic cookie encryption and decryption to Starlette applications, with extra support for existing cookie-based middleware.</p>"},{"location":"middleware/#timingmiddleware","title":"TimingMiddleware","text":"<p>A middleware class to emit timing information (cpu and wall time) for each request which passes through it.  Includes examples for how to emit these timings as statsd metrics.</p>"},{"location":"middleware/#wsgimiddleware","title":"WSGIMiddleware","text":"<p>A middleware class in charge of converting a WSGI application into an ASGI one.</p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#0473-august-24-2025","title":"0.47.3 (August 24, 2025)","text":""},{"location":"release-notes/#fixed","title":"Fixed","text":"<ul> <li>Use <code>asyncio.iscoroutinefunction</code> for Python 3.12 and older #2984.</li> </ul>"},{"location":"release-notes/#0472-july-20-2025","title":"0.47.2 (July 20, 2025)","text":""},{"location":"release-notes/#fixed_1","title":"Fixed","text":"<ul> <li>Make <code>UploadFile</code> check for future rollover #2962.</li> </ul>"},{"location":"release-notes/#0471-june-21-2025","title":"0.47.1 (June 21, 2025)","text":""},{"location":"release-notes/#fixed_2","title":"Fixed","text":"<ul> <li>Use <code>Self</code> in <code>TestClient.__enter__</code> #2951.</li> <li>Allow async exception handlers to type-check #2949.</li> </ul>"},{"location":"release-notes/#0470-may-29-2025","title":"0.47.0 (May 29, 2025)","text":""},{"location":"release-notes/#added","title":"Added","text":"<ul> <li>Add support for ASGI <code>pathsend</code> extension #2671.</li> <li>Add <code>partitioned</code> attribute to <code>Response.set_cookie</code> #2501.</li> </ul>"},{"location":"release-notes/#changed","title":"Changed","text":"<ul> <li>Change <code>methods</code> parameter type from <code>list[str]</code> to <code>Collection[str]</code> #2903.</li> <li>Replace <code>import typing</code> by <code>from typing import ...</code> in the whole codebase   #2867.</li> </ul>"},{"location":"release-notes/#fixed_3","title":"Fixed","text":"<ul> <li>Mark <code>ExceptionMiddleware.http_exception</code> as async to prevent thread creation   #2922.</li> </ul>"},{"location":"release-notes/#0462-april-13-2025","title":"0.46.2 (April 13, 2025)","text":""},{"location":"release-notes/#fixed_4","title":"Fixed","text":"<ul> <li>Prevents reraising of exception from BaseHttpMiddleware #2911.</li> <li>Use correct index on backwards compatible logic in <code>TemplateResponse</code> #2909.</li> </ul>"},{"location":"release-notes/#0461-march-8-2025","title":"0.46.1 (March 8, 2025)","text":""},{"location":"release-notes/#fixed_5","title":"Fixed","text":"<ul> <li>Allow relative directory path when <code>follow_symlinks=True</code> #2896.</li> </ul>"},{"location":"release-notes/#0460-february-22-2025","title":"0.46.0 (February 22, 2025)","text":""},{"location":"release-notes/#added_1","title":"Added","text":"<ul> <li><code>GZipMiddleware</code>: Make sure <code>Vary</code> header is always added if a response can be compressed #2865.</li> </ul>"},{"location":"release-notes/#fixed_6","title":"Fixed","text":"<ul> <li>Raise exception from background task on BaseHTTPMiddleware #2812.</li> <li><code>GZipMiddleware</code>: Don't compress on server sent events #2871.</li> </ul>"},{"location":"release-notes/#changed_1","title":"Changed","text":"<ul> <li><code>MultiPartParser</code>: Rename <code>max_file_size</code> to <code>spool_max_size</code> #2780.</li> </ul>"},{"location":"release-notes/#deprecated","title":"Deprecated","text":"<ul> <li>Add deprecated warning to <code>TestClient(timeout=...)</code> #2840.</li> </ul>"},{"location":"release-notes/#0453-january-24-2025","title":"0.45.3 (January 24, 2025)","text":""},{"location":"release-notes/#fixed_7","title":"Fixed","text":"<ul> <li>Turn directory into string on <code>lookup_path</code> on commonpath comparison #2851.</li> </ul>"},{"location":"release-notes/#0452-january-4-2025","title":"0.45.2 (January 4, 2025)","text":""},{"location":"release-notes/#fixed_8","title":"Fixed","text":"<ul> <li>Make <code>create_memory_object_stream</code> compatible with old anyio versions once again, and bump anyio minimum version to 3.6.2 #2833.</li> </ul>"},{"location":"release-notes/#0451-december-30-2024","title":"0.45.1 (December 30, 2024)","text":""},{"location":"release-notes/#fixed_9","title":"Fixed","text":"<ul> <li>Close <code>MemoryObjectReceiveStream</code> left unclosed upon exception in <code>BaseHTTPMiddleware</code> children #2813.</li> <li>Collect errors more reliably from the WebSocket logic on the <code>TestClient</code> #2814.</li> </ul>"},{"location":"release-notes/#refactor","title":"Refactor","text":"<ul> <li>Use a pair of memory object streams instead of two queues on the <code>TestClient</code> #2829.</li> </ul>"},{"location":"release-notes/#0450-december-29-2024","title":"0.45.0 (December 29, 2024)","text":""},{"location":"release-notes/#removed","title":"Removed","text":"<ul> <li>Drop Python 3.8 support #2823.</li> <li>Remove <code>ExceptionMiddleware</code> import proxy from <code>starlette.exceptions</code> module #2826.</li> <li>Remove deprecated <code>WS_1004_NO_STATUS_RCVD</code> and <code>WS_1005_ABNORMAL_CLOSURE</code> #2827.</li> </ul>"},{"location":"release-notes/#0440-december-28-2024","title":"0.44.0 (December 28, 2024)","text":""},{"location":"release-notes/#added_2","title":"Added","text":"<ul> <li>Add <code>client</code> parameter to <code>TestClient</code> #2810.</li> <li>Add <code>max_part_size</code> parameter to <code>Request.form()</code> #2815.</li> </ul>"},{"location":"release-notes/#0430-december-25-2024","title":"0.43.0 (December 25, 2024)","text":""},{"location":"release-notes/#removed_1","title":"Removed","text":"<ul> <li>Remove deprecated <code>allow_redirects</code> argument from <code>TestClient</code> #2808.</li> </ul>"},{"location":"release-notes/#added_3","title":"Added","text":"<ul> <li>Make UUID path parameter conversion more flexible #2806.</li> </ul>"},{"location":"release-notes/#0420-december-14-2024","title":"0.42.0 (December 14, 2024)","text":""},{"location":"release-notes/#added_4","title":"Added","text":"<ul> <li>Raise <code>ClientDisconnect</code> on <code>StreamingResponse</code> #2732.</li> </ul>"},{"location":"release-notes/#fixed_10","title":"Fixed","text":"<ul> <li>Use ETag from headers when parsing If-Range in FileResponse #2761.</li> <li>Follow directory symlinks in <code>StaticFiles</code> when <code>follow_symlinks=True</code> #2711.</li> <li>Bump minimum <code>python-multipart</code> version to <code>0.0.18</code> 0ba8395.</li> <li>Bump minimum <code>httpx</code> version to <code>0.27.0</code> #2773.</li> </ul>"},{"location":"release-notes/#0413-november-18-2024","title":"0.41.3 (November 18, 2024)","text":""},{"location":"release-notes/#fixed_11","title":"Fixed","text":"<ul> <li>Exclude the query parameters from the <code>scope[raw_path]</code> on the <code>TestClient</code> #2716.</li> <li>Replace <code>dict</code> by <code>Mapping</code> on <code>HTTPException.headers</code> #2749.</li> <li>Correct middleware argument passing and improve factory pattern #2752.</li> </ul>"},{"location":"release-notes/#0412-october-27-2024","title":"0.41.2 (October 27, 2024)","text":""},{"location":"release-notes/#fixed_12","title":"Fixed","text":"<ul> <li>Revert bump on <code>python-multipart</code> on <code>starlette[full]</code> extras #2737.</li> </ul>"},{"location":"release-notes/#0411-october-24-2024","title":"0.41.1 (October 24, 2024)","text":""},{"location":"release-notes/#fixed_13","title":"Fixed","text":"<ul> <li>Bump minimum <code>python-multipart</code> version to <code>0.0.13</code> #2734.</li> <li>Change <code>python-multipart</code> import to <code>python_multipart</code> #2733.</li> </ul>"},{"location":"release-notes/#0410-october-15-2024","title":"0.41.0 (October 15, 2024)","text":""},{"location":"release-notes/#added_5","title":"Added","text":"<ul> <li>Allow to raise <code>HTTPException</code> before <code>websocket.accept()</code> #2725.</li> </ul>"},{"location":"release-notes/#0400-october-15-2024","title":"0.40.0 (October 15, 2024)","text":"<p>This release fixes a Denial of service (DoS) via <code>multipart/form-data</code> requests.</p> <p>You can view the full security advisory: GHSA-f96h-pmfr-66vw</p>"},{"location":"release-notes/#fixed_14","title":"Fixed","text":"<ul> <li>Add <code>max_part_size</code> to <code>MultiPartParser</code> to limit the size of parts in <code>multipart/form-data</code>   requests fd038f3.</li> </ul>"},{"location":"release-notes/#0392-september-29-2024","title":"0.39.2 (September 29, 2024)","text":""},{"location":"release-notes/#fixed_15","title":"Fixed","text":"<ul> <li>Allow use of <code>request.url_for</code> when only \"app\" scope is available #2672.</li> <li>Fix internal type hints to support <code>python-multipart==0.0.12</code> #2708.</li> </ul>"},{"location":"release-notes/#0391-september-25-2024","title":"0.39.1 (September 25, 2024)","text":""},{"location":"release-notes/#fixed_16","title":"Fixed","text":"<ul> <li>Avoid regex re-compilation in <code>responses.py</code> and <code>schemas.py</code> #2700.</li> <li>Improve performance of <code>get_route_path</code> by removing regular expression usage   #2701.</li> <li>Consider <code>FileResponse.chunk_size</code> when handling multiple ranges #2703.</li> <li>Use <code>token_hex</code> for generating multipart boundary strings #2702.</li> </ul>"},{"location":"release-notes/#0390-september-23-2024","title":"0.39.0 (September 23, 2024)","text":""},{"location":"release-notes/#added_6","title":"Added","text":"<ul> <li>Add support for HTTP Range to   <code>FileResponse</code> #2697.</li> </ul>"},{"location":"release-notes/#0386-september-22-2024","title":"0.38.6 (September 22, 2024)","text":""},{"location":"release-notes/#fixed_17","title":"Fixed","text":"<ul> <li>Close unclosed <code>MemoryObjectReceiveStream</code> in <code>TestClient</code> #2693.</li> </ul>"},{"location":"release-notes/#0385-september-7-2024","title":"0.38.5 (September 7, 2024)","text":""},{"location":"release-notes/#fixed_18","title":"Fixed","text":"<ul> <li>Schedule <code>BackgroundTasks</code> from within <code>BaseHTTPMiddleware</code> #2688.   This behavior was removed in 0.38.3, and is now restored.</li> </ul>"},{"location":"release-notes/#0384-september-1-2024","title":"0.38.4 (September 1, 2024)","text":""},{"location":"release-notes/#fixed_19","title":"Fixed","text":"<ul> <li>Ensure accurate <code>root_path</code> removal in <code>get_route_path</code> function #2600.</li> </ul>"},{"location":"release-notes/#0383-september-1-2024","title":"0.38.3 (September 1, 2024)","text":""},{"location":"release-notes/#added_7","title":"Added","text":"<ul> <li>Support for Python 3.13 #2662.</li> </ul>"},{"location":"release-notes/#fixed_20","title":"Fixed","text":"<ul> <li>Don't poll for disconnects in <code>BaseHTTPMiddleware</code> via <code>StreamingResponse</code> #2620.</li> </ul>"},{"location":"release-notes/#0382-july-27-2024","title":"0.38.2 (July 27, 2024)","text":""},{"location":"release-notes/#fixed_21","title":"Fixed","text":"<ul> <li>Not assume all routines have <code>__name__</code> on <code>routing.get_name()</code> #2648.</li> </ul>"},{"location":"release-notes/#0381-july-23-2024","title":"0.38.1 (July 23, 2024)","text":""},{"location":"release-notes/#removed_2","title":"Removed","text":"<ul> <li>Revert \"Add support for ASGI pathsend extension\" #2649.</li> </ul>"},{"location":"release-notes/#0380-july-20-2024","title":"0.38.0 (July 20, 2024)","text":""},{"location":"release-notes/#added_8","title":"Added","text":"<ul> <li>Allow use of <code>memoryview</code> in <code>StreamingResponse</code> and <code>Response</code> #2576   and #2577.</li> <li>Send 404 instead of 500 when filename requested is too long on <code>StaticFiles</code> #2583.</li> </ul>"},{"location":"release-notes/#changed_2","title":"Changed","text":"<ul> <li>Fail fast on invalid <code>Jinja2Template</code> instantiation parameters #2568.</li> <li>Check endpoint handler is async only once #2536.</li> </ul>"},{"location":"release-notes/#fixed_22","title":"Fixed","text":"<ul> <li>Add proper synchronization to <code>WebSocketTestSession</code> #2597.</li> </ul>"},{"location":"release-notes/#0372-march-5-2024","title":"0.37.2 (March 5, 2024)","text":""},{"location":"release-notes/#added_9","title":"Added","text":"<ul> <li>Add <code>bytes</code> to <code>_RequestData</code> type #2510.</li> </ul>"},{"location":"release-notes/#fixed_23","title":"Fixed","text":"<ul> <li>Revert \"Turn <code>scope[\"client\"]</code> to <code>None</code> on <code>TestClient</code> (#2377)\" #2525.</li> <li>Remove deprecated <code>app</code> argument passed to <code>httpx.Client</code> on the <code>TestClient</code> #2526.</li> </ul>"},{"location":"release-notes/#0371-february-9-2024","title":"0.37.1 (February 9, 2024)","text":""},{"location":"release-notes/#fixed_24","title":"Fixed","text":"<ul> <li>Warn instead of raise for missing env file on <code>Config</code> #2485.</li> </ul>"},{"location":"release-notes/#0370-february-5-2024","title":"0.37.0 (February 5, 2024)","text":""},{"location":"release-notes/#added_10","title":"Added","text":"<ul> <li>Support the WebSocket Denial Response ASGI extension #2041.</li> </ul>"},{"location":"release-notes/#0363-february-4-2024","title":"0.36.3 (February 4, 2024)","text":""},{"location":"release-notes/#fixed_25","title":"Fixed","text":"<ul> <li>Create <code>anyio.Event</code> on async context #2459.</li> </ul>"},{"location":"release-notes/#0362-february-3-2024","title":"0.36.2 (February 3, 2024)","text":""},{"location":"release-notes/#fixed_26","title":"Fixed","text":"<ul> <li>Upgrade <code>python-multipart</code> to <code>0.0.7</code> 13e5c26.</li> <li>Avoid duplicate charset on <code>Content-Type</code> #2443.</li> </ul>"},{"location":"release-notes/#0361-january-23-2024","title":"0.36.1 (January 23, 2024)","text":""},{"location":"release-notes/#fixed_27","title":"Fixed","text":"<ul> <li>Check if \"extensions\" in scope before checking the extension #2438.</li> </ul>"},{"location":"release-notes/#0360-january-22-2024","title":"0.36.0 (January 22, 2024)","text":""},{"location":"release-notes/#added_11","title":"Added","text":"<ul> <li>Add support for ASGI <code>pathsend</code> extension #2435.</li> <li>Cancel <code>WebSocketTestSession</code> on close #2427.</li> <li>Raise <code>WebSocketDisconnect</code> when <code>WebSocket.send()</code> excepts <code>IOError</code> #2425.</li> <li>Raise <code>FileNotFoundError</code> when the <code>env_file</code> parameter on <code>Config</code> is not valid #2422.</li> </ul>"},{"location":"release-notes/#0351-january-11-2024","title":"0.35.1 (January 11, 2024)","text":""},{"location":"release-notes/#fixed_28","title":"Fixed","text":"<ul> <li>Stop using the deprecated \"method\" parameter in <code>FileResponse</code> inside of <code>StaticFiles</code> #2406.</li> <li>Make <code>typing-extensions</code> optional again #2409.</li> </ul>"},{"location":"release-notes/#0350-january-11-2024","title":"0.35.0 (January 11, 2024)","text":""},{"location":"release-notes/#added_12","title":"Added","text":"<ul> <li>Add <code>*args</code> to <code>Middleware</code> and improve its type hints #2381.</li> </ul>"},{"location":"release-notes/#fixed_29","title":"Fixed","text":"<ul> <li>Use <code>Iterable</code> instead <code>Iterator</code> on <code>iterate_in_threadpool</code> #2362.</li> </ul>"},{"location":"release-notes/#changes","title":"Changes","text":"<ul> <li>Handle <code>root_path</code> to keep compatibility with mounted ASGI applications and WSGI #2400.</li> <li>Turn <code>scope[\"client\"]</code> to <code>None</code> on <code>TestClient</code> #2377.</li> </ul>"},{"location":"release-notes/#0340-december-16-2023","title":"0.34.0 (December 16, 2023)","text":""},{"location":"release-notes/#added_13","title":"Added","text":"<ul> <li>Use <code>ParamSpec</code> for <code>run_in_threadpool</code> #2375.</li> <li>Add <code>UploadFile.__repr__</code> #2360.</li> </ul>"},{"location":"release-notes/#fixed_30","title":"Fixed","text":"<ul> <li>Merge URLs properly on <code>TestClient</code> #2376.</li> <li>Take weak ETags in consideration on <code>StaticFiles</code> #2334.</li> </ul>"},{"location":"release-notes/#deprecated_1","title":"Deprecated","text":"<ul> <li>Deprecate <code>FileResponse(method=...)</code> parameter #2366.</li> </ul>"},{"location":"release-notes/#0330-december-1-2023","title":"0.33.0 (December 1, 2023)","text":""},{"location":"release-notes/#added_14","title":"Added","text":"<ul> <li>Add <code>middleware</code> per <code>Route</code>/<code>WebSocketRoute</code> #2349.</li> <li>Add <code>middleware</code> per <code>Router</code> #2351.</li> </ul>"},{"location":"release-notes/#fixed_31","title":"Fixed","text":"<ul> <li>Do not overwrite <code>\"path\"</code> and <code>\"root_path\"</code> scope keys #2352.</li> <li>Set <code>ensure_ascii=False</code> on <code>json.dumps()</code> for <code>WebSocket.send_json()</code> #2341.</li> </ul>"},{"location":"release-notes/#0320post1-november-5-2023","title":"0.32.0.post1 (November 5, 2023)","text":""},{"location":"release-notes/#fixed_32","title":"Fixed","text":"<ul> <li>Revert mkdocs-material from 9.1.17 to 9.4.7 #2326.</li> </ul>"},{"location":"release-notes/#0320-november-4-2023","title":"0.32.0 (November 4, 2023)","text":""},{"location":"release-notes/#added_15","title":"Added","text":"<ul> <li>Send <code>reason</code> on <code>WebSocketDisconnect</code> #2309.</li> <li>Add <code>domain</code> parameter to <code>SessionMiddleware</code> #2280.</li> </ul>"},{"location":"release-notes/#changed_3","title":"Changed","text":"<ul> <li>Inherit from <code>HTMLResponse</code> instead of <code>Response</code> on <code>_TemplateResponse</code> #2274.</li> <li>Restore the <code>Response.render</code> type annotation to its pre-0.31.0 state #2264.</li> </ul>"},{"location":"release-notes/#0311-august-26-2023","title":"0.31.1 (August 26, 2023)","text":""},{"location":"release-notes/#fixed_33","title":"Fixed","text":"<ul> <li>Fix import error when <code>exceptiongroup</code> isn't available #2231.</li> <li>Set <code>url_for</code> global for custom Jinja environments #2230.</li> </ul>"},{"location":"release-notes/#0310-july-24-2023","title":"0.31.0 (July 24, 2023)","text":""},{"location":"release-notes/#added_16","title":"Added","text":"<ul> <li>Officially support Python 3.12 #2214.</li> <li>Support AnyIO 4.0 #2211.</li> <li>Strictly type annotate Starlette (strict mode on mypy) #2180.</li> </ul>"},{"location":"release-notes/#fixed_34","title":"Fixed","text":"<ul> <li>Don't group duplicated headers on a single string when using the <code>TestClient</code> #2219.</li> </ul>"},{"location":"release-notes/#0300-july-13-2023","title":"0.30.0 (July 13, 2023)","text":""},{"location":"release-notes/#removed_3","title":"Removed","text":"<ul> <li>Drop Python 3.7 support #2178.</li> </ul>"},{"location":"release-notes/#0290-july-13-2023","title":"0.29.0 (July 13, 2023)","text":""},{"location":"release-notes/#added_17","title":"Added","text":"<ul> <li>Add <code>follow_redirects</code> parameter to <code>TestClient</code> #2207.</li> <li>Add <code>__str__</code> to <code>HTTPException</code> and <code>WebSocketException</code> #2181.</li> <li>Warn users when using <code>lifespan</code> together with <code>on_startup</code>/<code>on_shutdown</code> #2193.</li> <li>Collect routes from <code>Host</code> to generate the OpenAPI schema #2183.</li> <li>Add <code>request</code> argument to <code>TemplateResponse</code> #2191.</li> </ul>"},{"location":"release-notes/#fixed_35","title":"Fixed","text":"<ul> <li>Stop <code>body_stream</code> in case <code>more_body=False</code> on <code>BaseHTTPMiddleware</code> #2194.</li> </ul>"},{"location":"release-notes/#0280-june-7-2023","title":"0.28.0 (June 7, 2023)","text":""},{"location":"release-notes/#changed_4","title":"Changed","text":"<ul> <li>Reuse <code>Request</code>'s body buffer for call_next in <code>BaseHTTPMiddleware</code> #1692.</li> <li>Move exception handling logic to <code>Route</code> #2026.</li> </ul>"},{"location":"release-notes/#added_18","title":"Added","text":"<ul> <li>Add <code>env</code> parameter to <code>Jinja2Templates</code>, and deprecate <code>**env_options</code> #2159.</li> <li>Add clear error message when <code>httpx</code> is not installed #2177.</li> </ul>"},{"location":"release-notes/#fixed_36","title":"Fixed","text":"<ul> <li>Allow \"name\" argument on <code>templates url_for()</code> #2127.</li> </ul>"},{"location":"release-notes/#0270-may-16-2023","title":"0.27.0 (May 16, 2023)","text":"<p>This release fixes a path traversal vulnerability in <code>StaticFiles</code>. You can view the full security advisory: https://github.com/encode/starlette/security/advisories/GHSA-v5gw-mw7f-84px</p>"},{"location":"release-notes/#added_19","title":"Added","text":"<ul> <li>Minify JSON websocket data via <code>send_json</code> https://github.com/encode/starlette/pull/2128</li> </ul>"},{"location":"release-notes/#fixed_37","title":"Fixed","text":"<ul> <li>Replace <code>commonprefix</code> by <code>commonpath</code> on <code>StaticFiles</code> 1797de4.</li> <li>Convert ImportErrors into ModuleNotFoundError #2135.</li> <li>Correct the RuntimeError message content in websockets #2141.</li> </ul>"},{"location":"release-notes/#0261-march-13-2023","title":"0.26.1 (March 13, 2023)","text":""},{"location":"release-notes/#fixed_38","title":"Fixed","text":"<ul> <li>Fix typing of Lifespan to allow subclasses of Starlette #2077.</li> </ul>"},{"location":"release-notes/#0260post1-march-9-2023","title":"0.26.0.post1 (March 9, 2023)","text":""},{"location":"release-notes/#fixed_39","title":"Fixed","text":"<ul> <li>Replace reference from Events to Lifespan on the mkdocs.yml #2072.</li> </ul>"},{"location":"release-notes/#0260-march-9-2023","title":"0.26.0 (March 9, 2023)","text":""},{"location":"release-notes/#added_20","title":"Added","text":"<ul> <li>Support lifespan state #2060,   #2065 and #2064.</li> </ul>"},{"location":"release-notes/#changed_5","title":"Changed","text":"<ul> <li>Change <code>url_for</code> signature to return a <code>URL</code> instance #1385.</li> </ul>"},{"location":"release-notes/#fixed_40","title":"Fixed","text":"<ul> <li>Allow \"name\" argument on <code>url_for()</code> and <code>url_path_for()</code> #2050.</li> </ul>"},{"location":"release-notes/#deprecated_2","title":"Deprecated","text":"<ul> <li>Deprecate <code>on_startup</code> and <code>on_shutdown</code> events #2070.</li> </ul>"},{"location":"release-notes/#0250-february-14-2023","title":"0.25.0 (February 14, 2023)","text":""},{"location":"release-notes/#fix","title":"Fix","text":"<ul> <li>Limit the number of fields and files when parsing <code>multipart/form-data</code> on the <code>MultipartParser</code> 8c74c2c and #2036.</li> </ul>"},{"location":"release-notes/#0240-february-6-2023","title":"0.24.0 (February 6, 2023)","text":""},{"location":"release-notes/#added_21","title":"Added","text":"<ul> <li>Allow <code>StaticFiles</code> to follow symlinks #1683.</li> <li>Allow <code>Request.form()</code> as a context manager #1903.</li> <li>Add <code>size</code> attribute to <code>UploadFile</code> #1405.</li> <li>Add <code>env_prefix</code> argument to <code>Config</code> #1990.</li> <li>Add template context processors #1904.</li> <li>Support <code>str</code> and <code>datetime</code> on <code>expires</code> parameter on the <code>Response.set_cookie</code> method #1908.</li> </ul>"},{"location":"release-notes/#changed_6","title":"Changed","text":"<ul> <li>Lazily build the middleware stack #2017.</li> <li>Make the <code>file</code> argument required on <code>UploadFile</code> #1413.</li> <li>Use debug extension instead of custom response template extension #1991.</li> </ul>"},{"location":"release-notes/#fixed_41","title":"Fixed","text":"<ul> <li>Fix url parsing of ipv6 urls on <code>URL.replace</code> #1965.</li> </ul>"},{"location":"release-notes/#0231-december-9-2022","title":"0.23.1 (December 9, 2022)","text":""},{"location":"release-notes/#fixed_42","title":"Fixed","text":"<ul> <li>Only stop receiving stream on <code>body_stream</code> if body is empty on the <code>BaseHTTPMiddleware</code> #1940.</li> </ul>"},{"location":"release-notes/#0230-december-5-2022","title":"0.23.0 (December 5, 2022)","text":""},{"location":"release-notes/#added_22","title":"Added","text":"<ul> <li>Add <code>headers</code> parameter to the <code>TestClient</code> #1966.</li> </ul>"},{"location":"release-notes/#deprecated_3","title":"Deprecated","text":"<ul> <li>Deprecate <code>Starlette</code> and <code>Router</code> decorators #1897.</li> </ul>"},{"location":"release-notes/#fixed_43","title":"Fixed","text":"<ul> <li>Fix bug on <code>FloatConvertor</code> regex #1973.</li> </ul>"},{"location":"release-notes/#0220-november-17-2022","title":"0.22.0 (November 17, 2022)","text":""},{"location":"release-notes/#changed_7","title":"Changed","text":"<ul> <li>Bypass <code>GZipMiddleware</code> when response includes <code>Content-Encoding</code> #1901.</li> </ul>"},{"location":"release-notes/#fixed_44","title":"Fixed","text":"<ul> <li>Remove unneeded <code>unquote()</code> from query parameters on the <code>TestClient</code> #1953.</li> <li>Make sure <code>MutableHeaders._list</code> is actually a <code>list</code> #1917.</li> <li>Import compatibility with the next version of <code>AnyIO</code> #1936.</li> </ul>"},{"location":"release-notes/#0210-september-26-2022","title":"0.21.0 (September 26, 2022)","text":"<p>This release replaces the underlying HTTP client used on the <code>TestClient</code> (<code>requests</code> <code>httpx</code>), and as those clients differ a bit on their API, your test suite will likely break. To make the migration smoother, you can use the <code>bump-testclient</code> tool.</p>"},{"location":"release-notes/#changed_8","title":"Changed","text":"<ul> <li>Replace <code>requests</code> with <code>httpx</code> in <code>TestClient</code> #1376.</li> </ul>"},{"location":"release-notes/#added_23","title":"Added","text":"<ul> <li>Add <code>WebSocketException</code> and support for WebSocket exception handlers #1263.</li> <li>Add <code>middleware</code> parameter to <code>Mount</code> class #1649.</li> <li>Officially support Python 3.11 #1863.</li> <li>Implement <code>__repr__</code> for route classes #1864.</li> </ul>"},{"location":"release-notes/#fixed_45","title":"Fixed","text":"<ul> <li>Fix bug on which <code>BackgroundTasks</code> were cancelled when using <code>BaseHTTPMiddleware</code> and client disconnected #1715.</li> </ul>"},{"location":"release-notes/#0204-june-28-2022","title":"0.20.4 (June 28, 2022)","text":""},{"location":"release-notes/#fixed_46","title":"Fixed","text":"<ul> <li>Remove converter from path when generating OpenAPI schema #1648.</li> </ul>"},{"location":"release-notes/#0203-june-10-2022","title":"0.20.3 (June 10, 2022)","text":""},{"location":"release-notes/#fixed_47","title":"Fixed","text":"<ul> <li>Revert \"Allow <code>StaticFiles</code> to follow symlinks\" #1681.</li> </ul>"},{"location":"release-notes/#0202-june-7-2022","title":"0.20.2 (June 7, 2022)","text":""},{"location":"release-notes/#fixed_48","title":"Fixed","text":"<ul> <li>Fix regression on route paths with colons #1675.</li> <li>Allow <code>StaticFiles</code> to follow symlinks #1337.</li> </ul>"},{"location":"release-notes/#0201-may-28-2022","title":"0.20.1 (May 28, 2022)","text":""},{"location":"release-notes/#fixed_49","title":"Fixed","text":"<ul> <li>Improve detection of async callables #1444.</li> <li>Send 400 (Bad Request) when <code>boundary</code> is missing #1617.</li> <li>Send 400 (Bad Request) when missing \"name\" field on <code>Content-Disposition</code> header #1643.</li> <li>Do not send empty data to <code>StreamingResponse</code> on <code>BaseHTTPMiddleware</code> #1609.</li> <li>Add <code>__bool__</code> dunder for <code>Secret</code> #1625.</li> </ul>"},{"location":"release-notes/#0200-may-3-2022","title":"0.20.0 (May 3, 2022)","text":""},{"location":"release-notes/#removed_4","title":"Removed","text":"<ul> <li>Drop Python 3.6 support #1357 and #1616.</li> </ul>"},{"location":"release-notes/#0191-april-22-2022","title":"0.19.1 (April 22, 2022)","text":""},{"location":"release-notes/#fixed_50","title":"Fixed","text":"<ul> <li>Fix inference of <code>Route.name</code> when created from methods #1553.</li> <li>Avoid <code>TypeError</code> on <code>websocket.disconnect</code> when code is <code>None</code> #1574.</li> </ul>"},{"location":"release-notes/#deprecated_4","title":"Deprecated","text":"<ul> <li>Deprecate <code>WS_1004_NO_STATUS_RCVD</code> and <code>WS_1005_ABNORMAL_CLOSURE</code> in favor of <code>WS_1005_NO_STATUS_RCVD</code> and <code>WS_1006_ABNORMAL_CLOSURE</code>, as the previous constants didn't match the WebSockets specs #1580.</li> </ul>"},{"location":"release-notes/#0190-march-9-2022","title":"0.19.0 (March 9, 2022)","text":""},{"location":"release-notes/#added_24","title":"Added","text":"<ul> <li>Error handler will always run, even if the error happens on a background task #761.</li> <li>Add <code>headers</code> parameter to <code>HTTPException</code> #1435.</li> <li>Internal responses with <code>405</code> status code insert an <code>Allow</code> header, as described by RFC 7231 #1436.</li> <li>The <code>content</code> argument in <code>JSONResponse</code> is now required #1431.</li> <li>Add custom URL convertor register #1437.</li> <li>Add content disposition type parameter to <code>FileResponse</code> #1266.</li> <li>Add next query param with original request URL in requires decorator #920.</li> <li>Add <code>raw_path</code> to <code>TestClient</code> scope #1445.</li> <li>Add union operators to <code>MutableHeaders</code> #1240.</li> <li>Display missing route details on debug page #1363.</li> <li>Change <code>anyio</code> required version range to <code>&gt;=3.4.0,&lt;5.0</code> #1421 and #1460.</li> <li>Add <code>typing-extensions&gt;=3.10</code> requirement - used only on lower versions than Python 3.10 #1475.</li> </ul>"},{"location":"release-notes/#fixed_51","title":"Fixed","text":"<ul> <li>Prevent <code>BaseHTTPMiddleware</code> from hiding errors of <code>StreamingResponse</code> and mounted applications #1459.</li> <li><code>SessionMiddleware</code> uses an explicit <code>path=...</code>, instead of defaulting to the ASGI 'root_path' #1512.</li> <li><code>Request.client</code> is now compliant with the ASGI specifications #1462.</li> <li>Raise <code>KeyError</code> at early stage for missing boundary #1349.</li> </ul>"},{"location":"release-notes/#deprecated_5","title":"Deprecated","text":"<ul> <li>Deprecate WSGIMiddleware in favor of a2wsgi #1504.</li> <li>Deprecate <code>run_until_first_complete</code> #1443.</li> </ul>"},{"location":"release-notes/#0180-january-23-2022","title":"0.18.0 (January 23, 2022)","text":""},{"location":"release-notes/#added_25","title":"Added","text":"<ul> <li>Change default chunk size from 4Kb to 64Kb on <code>FileResponse</code> #1345.</li> <li>Add support for <code>functools.partial</code> in <code>WebSocketRoute</code> #1356.</li> <li>Add <code>StaticFiles</code> packages with directory #1350.</li> <li>Allow environment options in <code>Jinja2Templates</code> #1401.</li> <li>Allow HEAD method on <code>HttpEndpoint</code> #1346.</li> <li>Accept additional headers on <code>websocket.accept</code> message #1361 and #1422.</li> <li>Add <code>reason</code> to <code>WebSocket</code> close ASGI event #1417.</li> <li>Add headers attribute to <code>UploadFile</code> #1382.</li> <li>Don't omit <code>Content-Length</code> header for <code>Content-Length: 0</code> cases #1395.</li> <li>Don't set headers for responses with 1xx, 204 and 304 status code #1397.</li> <li><code>SessionMiddleware.max_age</code> now accepts <code>None</code>, so cookie can last as long as the browser session #1387.</li> </ul>"},{"location":"release-notes/#fixed_52","title":"Fixed","text":"<ul> <li>Tweak <code>hashlib.md5()</code> function on <code>FileResponse</code>s ETag generation. The parameter <code>usedforsecurity</code> flag is set to <code>False</code>, if the flag is available on the system. This fixes an error raised on systems with FIPS enabled #1366 and #1410.</li> <li>Fix <code>path_params</code> type on <code>url_path_for()</code> method i.e. turn <code>str</code> into <code>Any</code> #1341.</li> <li><code>Host</code> now ignores <code>port</code> on routing #1322.</li> </ul>"},{"location":"release-notes/#0171-november-17-2021","title":"0.17.1 (November 17, 2021)","text":""},{"location":"release-notes/#fixed_53","title":"Fixed","text":"<ul> <li>Fix <code>IndexError</code> in authentication <code>requires</code> when wrapped function arguments are distributed between <code>*args</code> and <code>**kwargs</code> #1335.</li> </ul>"},{"location":"release-notes/#0170-november-4-2021","title":"0.17.0 (November 4, 2021)","text":""},{"location":"release-notes/#added_26","title":"Added","text":"<ul> <li><code>Response.delete_cookie</code> now accepts the same parameters as <code>Response.set_cookie</code> #1228.</li> <li>Update the <code>Jinja2Templates</code> constructor to allow <code>PathLike</code> #1292.</li> </ul>"},{"location":"release-notes/#fixed_54","title":"Fixed","text":"<ul> <li>Fix BadSignature exception handling in SessionMiddleware #1264.</li> <li>Change <code>HTTPConnection.__getitem__</code> return type from <code>str</code> to <code>typing.Any</code> #1118.</li> <li>Change <code>ImmutableMultiDict.getlist</code> return type from <code>typing.List[str]</code> to <code>typing.List[typing.Any]</code> #1235.</li> <li>Handle <code>OSError</code> exceptions on <code>StaticFiles</code> #1220.</li> <li>Fix <code>StaticFiles</code> 404.html in HTML mode #1314.</li> <li>Prevent anyio.ExceptionGroup in error views under a BaseHTTPMiddleware #1262.</li> </ul>"},{"location":"release-notes/#removed_5","title":"Removed","text":"<ul> <li>Remove GraphQL support #1198.</li> </ul>"},{"location":"release-notes/#0160-july-19-2021","title":"0.16.0 (July 19, 2021)","text":""},{"location":"release-notes/#added_27","title":"Added","text":"<ul> <li>Added Encode funding option    #1219</li> </ul>"},{"location":"release-notes/#fixed_55","title":"Fixed","text":"<ul> <li><code>starlette.websockets.WebSocket</code> instances are now hashable and compare by identity     #1039</li> <li>A number of fixes related to running task groups in lifespan    #1213,    #1227</li> </ul>"},{"location":"release-notes/#deprecatedremoved","title":"Deprecated/removed","text":"<ul> <li>The method <code>starlette.templates.Jinja2Templates.get_env</code> was removed    #1218</li> <li>The ClassVar <code>starlette.testclient.TestClient.async_backend</code> was removed,    the backend is now configured using constructor kwargs    #1211</li> <li>Passing an Async Generator Function or a Generator Function to <code>starlette.routing.Router(lifespan=)</code> is deprecated. You should wrap your lifespan in <code>@contextlib.asynccontextmanager</code>.    #1227 #1110</li> </ul>"},{"location":"release-notes/#0150-june-23-2021","title":"0.15.0 (June 23, 2021)","text":"<p>This release includes major changes to the low-level asynchronous parts of Starlette. As a result, Starlette now depends on AnyIO and some minor API changes have occurred. Another significant change with this release is the deprecation of built-in GraphQL support.</p>"},{"location":"release-notes/#added_28","title":"Added","text":"<ul> <li>Starlette now supports Trio as an async runtime via   AnyIO - #1157.</li> <li><code>TestClient.websocket_connect()</code> now must be used as a context manager.</li> <li>Initial support for Python 3.10 - #1201.</li> <li>The compression level used in <code>GZipMiddleware</code> is now adjustable -   #1128.</li> </ul>"},{"location":"release-notes/#fixed_56","title":"Fixed","text":"<ul> <li>Several fixes to <code>CORSMiddleware</code>. See #1111,   #1112,   #1113,   #1199.</li> <li>Improved exception messages in the case of duplicated path parameter names -   #1177.</li> <li><code>RedirectResponse</code> now uses <code>quote</code> instead of <code>quote_plus</code> encoding for the <code>Location</code> header   to better match the behaviour in other frameworks such as Django -   #1164.</li> <li>Exception causes are now preserved in more cases -   #1158.</li> <li>Session cookies now use the ASGI root path in the case of mounted applications -   #1147.</li> <li>Fixed a cache invalidation bug when static files were deleted in certain circumstances -   #1023.</li> <li>Improved memory usage of <code>BaseHTTPMiddleware</code> when handling large responses -   #1012 fixed via #1157</li> </ul>"},{"location":"release-notes/#deprecatedremoved_1","title":"Deprecated/removed","text":"<ul> <li>Built-in GraphQL support via the <code>GraphQLApp</code> class has been deprecated and will be removed in a   future release. Please see #619. GraphQL is not   supported on Python 3.10.</li> <li>The <code>executor</code> parameter to <code>GraphQLApp</code> was removed. Use <code>executor_class</code> instead.</li> <li>The <code>workers</code> parameter to <code>WSGIMiddleware</code> was removed. This hasn't had any effect since   Starlette v0.6.3.</li> </ul>"},{"location":"release-notes/#0142-february-2-2021","title":"0.14.2 (February 2, 2021)","text":""},{"location":"release-notes/#fixed_57","title":"Fixed","text":"<ul> <li>Fixed <code>ServerErrorMiddleware</code> compatibility with Python 3.9.1/3.8.7 when debug mode is enabled -   #1132.</li> <li>Fixed unclosed socket <code>ResourceWarning</code>s when using the <code>TestClient</code> with WebSocket endpoints -   #1132.</li> <li>Improved detection of <code>async</code> endpoints wrapped in <code>functools.partial</code> on Python 3.8+ -   #1106.</li> </ul>"},{"location":"release-notes/#0141-november-9th-2020","title":"0.14.1 (November 9th, 2020)","text":""},{"location":"release-notes/#removed_6","title":"Removed","text":"<ul> <li><code>UJSONResponse</code> was removed (this change was intended to be included in 0.14.0). Please see the   documentation for how to   implement responses using custom JSON serialization -   #1074.</li> </ul>"},{"location":"release-notes/#0140-november-8th-2020","title":"0.14.0 (November 8th, 2020)","text":""},{"location":"release-notes/#added_29","title":"Added","text":"<ul> <li>Starlette now officially supports Python3.9.</li> <li>In <code>StreamingResponse</code>, allow custom async iterator such as objects from classes implementing <code>__aiter__</code>.</li> <li>Allow usage of <code>functools.partial</code> async handlers in Python versions 3.6 and 3.7.</li> <li>Add 418 I'm A Teapot status code.</li> </ul>"},{"location":"release-notes/#changed_9","title":"Changed","text":"<ul> <li>Create tasks from handler coroutines before sending them to <code>asyncio.wait</code>.</li> <li>Use <code>format_exception</code> instead of <code>format_tb</code> in <code>ServerErrorMiddleware</code>'s <code>debug</code> responses.</li> <li>Be more lenient with handler arguments when using the <code>requires</code> decorator.</li> </ul>"},{"location":"release-notes/#0138","title":"0.13.8","text":"<ul> <li> <p>Revert <code>Queue(maxsize=1)</code> fix for <code>BaseHTTPMiddleware</code> middleware classes and streaming responses.</p> </li> <li> <p>The <code>StaticFiles</code> constructor now allows <code>pathlib.Path</code> in addition to strings for its <code>directory</code> argument.</p> </li> </ul>"},{"location":"release-notes/#0137","title":"0.13.7","text":"<ul> <li>Fix high memory usage when using <code>BaseHTTPMiddleware</code> middleware classes and streaming responses.</li> </ul>"},{"location":"release-notes/#0136","title":"0.13.6","text":"<ul> <li>Fix 404 errors with <code>StaticFiles</code>.</li> </ul>"},{"location":"release-notes/#0135","title":"0.13.5","text":"<ul> <li>Add support for <code>Starlette(lifespan=...)</code> functions.</li> <li>More robust path-traversal check in StaticFiles app.</li> <li>Fix WSGI PATH_INFO encoding.</li> <li>RedirectResponse now accepts optional background parameter</li> <li>Allow path routes to contain regex meta characters</li> <li>Treat ASGI HTTP 'body' as an optional key.</li> <li>Don't use thread pooling for writing to in-memory upload files.</li> </ul>"},{"location":"release-notes/#0130","title":"0.13.0","text":"<ul> <li>Switch to promoting application configuration on init style everywhere.   This means dropping the decorator style in favour of declarative routing   tables and middleware definitions.</li> </ul>"},{"location":"release-notes/#01212","title":"0.12.12","text":"<ul> <li>Fix <code>request.url_for()</code> for the Mount-within-a-Mount case.</li> </ul>"},{"location":"release-notes/#01211","title":"0.12.11","text":"<ul> <li>Fix <code>request.url_for()</code> when an ASGI <code>root_path</code> is being used.</li> </ul>"},{"location":"release-notes/#0121","title":"0.12.1","text":"<ul> <li>Add <code>URL.include_query_params(**kwargs)</code></li> <li>Add <code>URL.replace_query_params(**kwargs)</code></li> <li>Add <code>URL.remove_query_params(param_names)</code></li> <li><code>request.state</code> properly persisting across middleware.</li> <li>Added <code>request.scope</code> interface.</li> </ul>"},{"location":"release-notes/#0120","title":"0.12.0","text":"<ul> <li>Switch to ASGI 3.0.</li> <li>Fixes to CORS middleware.</li> <li>Add <code>StaticFiles(html=True)</code> support.</li> <li>Fix path quoting in redirect responses.</li> </ul>"},{"location":"release-notes/#0111","title":"0.11.1","text":"<ul> <li>Add <code>request.state</code> interface, for storing arbitrary additional information.</li> <li>Support disabling GraphiQL with <code>GraphQLApp(..., graphiql=False)</code>.</li> </ul>"},{"location":"release-notes/#0110","title":"0.11.0","text":"<ul> <li><code>DatabaseMiddleware</code> is now dropped in favour of <code>databases</code></li> <li>Templates are no longer configured on the application instance. Use <code>templates = Jinja2Templates(directory=...)</code> and <code>return templates.TemplateResponse('index.html', {\"request\": request})</code></li> <li>Schema generation is no longer attached to the application instance. Use <code>schemas = SchemaGenerator(...)</code> and <code>return schemas.OpenAPIResponse(request=request)</code></li> <li><code>LifespanMiddleware</code> is dropped in favor of router-based lifespan handling.</li> <li>Application instances now accept a <code>routes</code> argument, <code>Starlette(routes=[...])</code></li> <li>Schema generation now includes mounted routes.</li> </ul>"},{"location":"release-notes/#0106","title":"0.10.6","text":"<ul> <li>Add <code>Lifespan</code> routing component.</li> </ul>"},{"location":"release-notes/#0105","title":"0.10.5","text":"<ul> <li>Ensure <code>templating</code> does not strictly require <code>jinja2</code> to be installed.</li> </ul>"},{"location":"release-notes/#0104","title":"0.10.4","text":"<ul> <li>Templates are now configured independently from the application instance. <code>templates = Jinja2Templates(directory=...)</code>. Existing API remains in place, but is no longer documented, and will be deprecated in due course. See the template documentation for more details.</li> </ul>"},{"location":"release-notes/#0103","title":"0.10.3","text":"<ul> <li>Move to independent <code>databases</code> package instead of <code>DatabaseMiddleware</code>. Existing API remains in place, but is no longer documented, and will be deprecated in due course.</li> </ul>"},{"location":"release-notes/#0102","title":"0.10.2","text":"<ul> <li>Don't drop explicit port numbers on redirects from <code>HTTPSRedirectMiddleware</code>.</li> </ul>"},{"location":"release-notes/#0101","title":"0.10.1","text":"<ul> <li>Add MySQL database support.</li> <li>Add host-based routing.</li> </ul>"},{"location":"release-notes/#0100","title":"0.10.0","text":"<ul> <li>WebSockets now default to sending/receiving JSON over text data frames. Use <code>.send_json(data, mode=\"binary\")</code> and <code>.receive_json(mode=\"binary\")</code> for binary framing.</li> <li><code>GraphQLApp</code> now takes an <code>executor_class</code> argument, which should be used in preference to the existing <code>executor</code> argument. Resolves an issue with async executors being instantiated before the event loop was setup. The <code>executor</code> argument is expected to be deprecated in the next median or major release.</li> <li>Authentication and the <code>@requires</code> decorator now support WebSocket endpoints.</li> <li><code>MultiDict</code> and <code>ImmutableMultiDict</code> classes are available in <code>uvicorn.datastructures</code>.</li> <li><code>QueryParams</code> is now instantiated with standard dict-style <code>*args, **kwargs</code> arguments.</li> </ul>"},{"location":"release-notes/#0911","title":"0.9.11","text":"<ul> <li>Session cookies now include browser 'expires', in addition to the existing signed expiry.</li> <li><code>request.form()</code> now returns a multi-dict interface.</li> <li>The query parameter multi-dict implementation now mirrors <code>dict</code> more correctly for the behavior of <code>.keys()</code>, <code>.values()</code>, and <code>.items()</code> when multiple same-key items occur.</li> <li>Use <code>urlsplit</code> throughout in favor of <code>urlparse</code>.</li> </ul>"},{"location":"release-notes/#0910","title":"0.9.10","text":"<ul> <li>Support <code>@requires(...)</code> on class methods.</li> <li>Apply URL escaping to form data.</li> <li>Support <code>HEAD</code> requests automatically.</li> <li>Add <code>await request.is_disconnected()</code>.</li> <li>Pass operationName to GraphQL executor.</li> </ul>"},{"location":"release-notes/#099","title":"0.9.9","text":"<ul> <li>Add <code>TemplateResponse</code>.</li> <li>Add <code>CommaSeparatedStrings</code> datatype.</li> <li>Add <code>BackgroundTasks</code> for multiple tasks.</li> <li>Common subclass for <code>Request</code> and <code>WebSocket</code>, to eg. share <code>session</code> functionality.</li> <li>Expose remote address with <code>request.client</code>.</li> </ul>"},{"location":"release-notes/#098","title":"0.9.8","text":"<ul> <li>Add <code>request.database.executemany</code>.</li> </ul>"},{"location":"release-notes/#097","title":"0.9.7","text":"<ul> <li>Ensure that <code>AuthenticationMiddleware</code> handles lifespan messages correctly.</li> </ul>"},{"location":"release-notes/#096","title":"0.9.6","text":"<ul> <li>Add <code>AuthenticationMiddleware</code>, and <code>@requires()</code> decorator.</li> </ul>"},{"location":"release-notes/#095","title":"0.9.5","text":"<ul> <li>Support either <code>str</code> or <code>Secret</code> for <code>SessionMiddleware(secret_key=...)</code>.</li> </ul>"},{"location":"release-notes/#094","title":"0.9.4","text":"<ul> <li>Add <code>config.environ</code>.</li> <li>Add <code>datastructures.Secret</code>.</li> <li>Add <code>datastructures.DatabaseURL</code>.</li> </ul>"},{"location":"release-notes/#093","title":"0.9.3","text":"<ul> <li>Add <code>config.Config(\".env\")</code></li> </ul>"},{"location":"release-notes/#092","title":"0.9.2","text":"<ul> <li>Add optional database support.</li> <li>Add <code>request</code> to GraphQL context.</li> <li>Hide any password component in <code>URL.__repr__</code>.</li> </ul>"},{"location":"release-notes/#091","title":"0.9.1","text":"<ul> <li>Handle startup/shutdown errors properly.</li> </ul>"},{"location":"release-notes/#090","title":"0.9.0","text":"<ul> <li><code>TestClient</code> can now be used as a context manager, instead of <code>LifespanContext</code>.</li> <li>Lifespan is now handled as middleware. Startup and Shutdown events are visible throughout the middleware stack.</li> </ul>"},{"location":"release-notes/#088","title":"0.8.8","text":"<ul> <li>Better support for third-party API schema generators.</li> </ul>"},{"location":"release-notes/#087","title":"0.8.7","text":"<ul> <li>Support chunked requests with TestClient.</li> <li>Cleanup asyncio tasks properly with WSGIMiddleware.</li> <li>Support using TestClient within endpoints, for service mocking.</li> </ul>"},{"location":"release-notes/#086","title":"0.8.6","text":"<ul> <li>Session cookies are now set on the root path.</li> </ul>"},{"location":"release-notes/#085","title":"0.8.5","text":"<ul> <li>Support URL convertors.</li> <li>Support HTTP 304 cache responses from <code>StaticFiles</code>.</li> <li>Resolve character escaping issue with form data.</li> </ul>"},{"location":"release-notes/#084","title":"0.8.4","text":"<ul> <li>Default to empty body on responses.</li> </ul>"},{"location":"release-notes/#083","title":"0.8.3","text":"<ul> <li>Add 'name' argument to <code>@app.route()</code>.</li> <li>Use 'Host' header for URL reconstruction.</li> </ul>"},{"location":"release-notes/#082","title":"0.8.2","text":""},{"location":"release-notes/#staticfiles","title":"StaticFiles","text":"<ul> <li>StaticFiles no longer reads the file for responses to <code>HEAD</code> requests.</li> </ul>"},{"location":"release-notes/#081","title":"0.8.1","text":""},{"location":"release-notes/#templating","title":"Templating","text":"<ul> <li>Add a default templating configuration with Jinja2.</li> </ul> <p>Allows the following:</p> <pre><code>app = Starlette(template_directory=\"templates\")\n\n@app.route('/')\nasync def homepage(request):\n    # `url_for` is available inside the template.\n    template = app.get_template('index.html')\n    content = template.render(request=request)\n    return HTMLResponse(content)\n</code></pre>"},{"location":"release-notes/#080","title":"0.8.0","text":""},{"location":"release-notes/#exceptions","title":"Exceptions","text":"<ul> <li>Add support for <code>@app.exception_handler(404)</code>.</li> <li>Ensure handled exceptions are not seen as errors by the middleware stack.</li> </ul>"},{"location":"release-notes/#sessionmiddleware","title":"SessionMiddleware","text":"<ul> <li>Add <code>max_age</code>, and use timestamp-signed cookies. Defaults to two weeks.</li> </ul>"},{"location":"release-notes/#cookies","title":"Cookies","text":"<ul> <li>Ensure cookies are strictly HTTP correct.</li> </ul>"},{"location":"release-notes/#staticfiles_1","title":"StaticFiles","text":"<ul> <li>Check directory exists on instantiation.</li> </ul>"},{"location":"release-notes/#074","title":"0.7.4","text":""},{"location":"release-notes/#concurrency","title":"Concurrency","text":"<ul> <li>Add <code>starlette.concurrency.run_in_threadpool</code>. Now handles <code>contextvar</code> support.</li> </ul>"},{"location":"release-notes/#073","title":"0.7.3","text":""},{"location":"release-notes/#routing","title":"Routing","text":"<ul> <li>Add <code>name=</code> support to <code>app.mount()</code>. This allows eg: <code>app.mount('/static', StaticFiles(directory='static'), name='static')</code>.</li> </ul>"},{"location":"release-notes/#072","title":"0.7.2","text":""},{"location":"release-notes/#middleware","title":"Middleware","text":"<ul> <li>Add support for <code>@app.middleware(\"http\")</code> decorator.</li> </ul>"},{"location":"release-notes/#routing_1","title":"Routing","text":"<ul> <li>Add \"endpoint\" to ASGI scope.</li> </ul>"},{"location":"release-notes/#071","title":"0.7.1","text":""},{"location":"release-notes/#debug-tracebacks","title":"Debug tracebacks","text":"<ul> <li>Improve debug traceback information &amp; styling.</li> </ul>"},{"location":"release-notes/#url-routing","title":"URL routing","text":"<ul> <li>Support mounted URL lookups with \"path=\", eg. <code>url_for('static', path=...)</code>.</li> <li>Support nested URL lookups, eg. <code>url_for('admin:user', username=...)</code>.</li> <li>Add redirect slashes support.</li> <li>Add www redirect support.</li> </ul>"},{"location":"release-notes/#background-tasks","title":"Background tasks","text":"<ul> <li>Add background task support to <code>FileResponse</code> and <code>StreamingResponse</code>.</li> </ul>"},{"location":"release-notes/#070","title":"0.7.0","text":""},{"location":"release-notes/#api-schema-support","title":"API Schema support","text":"<ul> <li>Add <code>app.schema_generator = SchemaGenerator(...)</code>.</li> <li>Add <code>app.schema</code> property.</li> <li>Add <code>OpenAPIResponse(...)</code>.</li> </ul>"},{"location":"release-notes/#graphql-routing","title":"GraphQL routing","text":"<ul> <li>Drop <code>app.add_graphql_route(\"/\", ...)</code> in favor of more consistent <code>app.add_route(\"/\", GraphQLApp(...))</code>.</li> </ul>"},{"location":"release-notes/#063","title":"0.6.3","text":""},{"location":"release-notes/#routing-api","title":"Routing API","text":"<ul> <li>Support routing to methods.</li> <li>Ensure <code>url_path_for</code> works with Mount('/{some_path_params}').</li> <li>Fix Router(default=) argument.</li> <li>Support repeated paths, like: <code>@app.route(\"/\", methods=[\"GET\"])</code>, <code>@app.route(\"/\", methods=[\"POST\"])</code></li> <li>Use the default ThreadPoolExecutor for all sync endpoints.</li> </ul>"},{"location":"release-notes/#062","title":"0.6.2","text":""},{"location":"release-notes/#sessionmiddleware_1","title":"SessionMiddleware","text":"<p>Added support for <code>request.session</code>, with <code>SessionMiddleware</code>.</p>"},{"location":"release-notes/#061","title":"0.6.1","text":""},{"location":"release-notes/#basehttpmiddleware","title":"BaseHTTPMiddleware","text":"<p>Added support for <code>BaseHTTPMiddleware</code>, which provides a standard request/response interface over a regular ASGI middleware.</p> <p>This means you can write ASGI middleware while still working at a request/response level, rather than handling ASGI messages directly.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\n\nclass CustomMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        response = await call_next(request)\n        response.headers['Custom-Header'] = 'Example'\n        return response\n\n\napp = Starlette()\napp.add_middleware(CustomMiddleware)\n</code></pre>"},{"location":"release-notes/#060","title":"0.6.0","text":""},{"location":"release-notes/#requestpath_params","title":"request.path_params","text":"<p>The biggest change in 0.6 is that endpoint signatures are no longer:</p> <pre><code>async def func(request: Request, **kwargs) -&gt; Response\n</code></pre> <p>Instead we just use:</p> <pre><code>async def func(request: Request) -&gt; Response\n</code></pre> <p>The path parameters are available on the request as <code>request.path_params</code>.</p> <p>This is different to most Python webframeworks, but I think it actually ends up being much more nicely consistent all the way through.</p>"},{"location":"release-notes/#requesturl_for","title":"request.url_for()","text":"<p>Request and WebSocketSession now support URL reversing with <code>request.url_for(name, **path_params)</code>. This method returns a fully qualified <code>URL</code> instance. The URL instance is a string-like object.</p>"},{"location":"release-notes/#appurl_path_for","title":"app.url_path_for()","text":"<p>Applications now support URL path reversing with <code>app.url_path_for(name, **path_params)</code>. This method returns a <code>URL</code> instance with the path and scheme set. The URL instance is a string-like object, and will return only the path if coerced to a string.</p>"},{"location":"release-notes/#approutes","title":"app.routes","text":"<p>Applications now support a <code>.routes</code> parameter, which returns a list of <code>[Route|WebSocketRoute|Mount]</code>.</p>"},{"location":"release-notes/#route-websocketroute-mount","title":"Route, WebSocketRoute, Mount","text":"<p>The low level components to <code>Router</code> now match the <code>@app.route()</code>, <code>@app.websocket_route()</code>, and <code>app.mount()</code> signatures.</p>"},{"location":"requests/","title":"Requests","text":"<p>Starlette includes a <code>Request</code> class that gives you a nicer interface onto the incoming request, rather than accessing the ASGI scope and receive channel directly.</p>"},{"location":"requests/#request","title":"Request","text":"<p>Signature: <code>Request(scope, receive=None)</code></p> <pre><code>from starlette.requests import Request\nfrom starlette.responses import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    content = '%s %s' % (request.method, request.url.path)\n    response = Response(content, media_type='text/plain')\n    await response(scope, receive, send)\n</code></pre> <p>Requests present a mapping interface, so you can use them in the same way as a <code>scope</code>.</p> <p>For instance: <code>request['path']</code> will return the ASGI path.</p> <p>If you don't need to access the request body you can instantiate a request without providing an argument to <code>receive</code>.</p>"},{"location":"requests/#method","title":"Method","text":"<p>The request method is accessed as <code>request.method</code>.</p>"},{"location":"requests/#url","title":"URL","text":"<p>The request URL is accessed as <code>request.url</code>.</p> <p>The property is a string-like object that exposes all the components that can be parsed out of the URL.</p> <p>For example: <code>request.url.path</code>, <code>request.url.port</code>, <code>request.url.scheme</code>.</p>"},{"location":"requests/#headers","title":"Headers","text":"<p>Headers are exposed as an immutable, case-insensitive, multi-dict.</p> <p>For example: <code>request.headers['content-type']</code></p>"},{"location":"requests/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are exposed as an immutable multi-dict.</p> <p>For example: <code>request.query_params['search']</code></p>"},{"location":"requests/#path-parameters","title":"Path Parameters","text":"<p>Router path parameters are exposed as a dictionary interface.</p> <p>For example: <code>request.path_params['username']</code></p>"},{"location":"requests/#client-address","title":"Client Address","text":"<p>The client's remote address is exposed as a named two-tuple <code>request.client</code> (or <code>None</code>).</p> <p>The hostname or IP address: <code>request.client.host</code></p> <p>The port number from which the client is connecting: <code>request.client.port</code></p>"},{"location":"requests/#cookies","title":"Cookies","text":"<p>Cookies are exposed as a regular dictionary interface.</p> <p>For example: <code>request.cookies.get('mycookie')</code></p> <p>Cookies are ignored in case of an invalid cookie. (RFC2109)</p>"},{"location":"requests/#body","title":"Body","text":"<p>There are a few different interfaces for returning the body of the request:</p> <p>The request body as bytes: <code>await request.body()</code></p> <p>The request body, parsed as form data or multipart: <code>async with request.form() as form:</code></p> <p>The request body, parsed as JSON: <code>await request.json()</code></p> <p>You can also access the request body as a stream, using the <code>async for</code> syntax:</p> <pre><code>from starlette.requests import Request\nfrom starlette.responses import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    request = Request(scope, receive)\n    body = b''\n    async for chunk in request.stream():\n        body += chunk\n    response = Response(body, media_type='text/plain')\n    await response(scope, receive, send)\n</code></pre> <p>If you access <code>.stream()</code> then the byte chunks are provided without storing the entire body to memory. Any subsequent calls to <code>.body()</code>, <code>.form()</code>, or <code>.json()</code> will raise an error.</p> <p>In some cases such as long-polling, or streaming responses you might need to determine if the client has dropped the connection. You can determine this state with <code>disconnected = await request.is_disconnected()</code>.</p>"},{"location":"requests/#request-files","title":"Request Files","text":"<p>Request files are normally sent as multipart form data (<code>multipart/form-data</code>).</p> <p>Signature: <code>request.form(max_files=1000, max_fields=1000, max_part_size=1024*1024)</code></p> <p>You can configure the number of maximum fields or files with the parameters <code>max_files</code> and <code>max_fields</code>; and part size using <code>max_part_size</code>:</p> <pre><code>async with request.form(max_files=1000, max_fields=1000, max_part_size=1024*1024):\n    ...\n</code></pre> <p>Info</p> <p>These limits are for security reasons, allowing an unlimited number of fields or files could lead to a denial of service attack by consuming a lot of CPU and memory parsing too many empty fields.</p> <p>When you call <code>async with request.form() as form</code> you receive a <code>starlette.datastructures.FormData</code> which is an immutable multidict, containing both file uploads and text input. File upload items are represented as instances of <code>starlette.datastructures.UploadFile</code>.</p> <p><code>UploadFile</code> has the following attributes:</p> <ul> <li><code>filename</code>: An <code>str</code> with the original file name that was uploaded or <code>None</code> if its not available (e.g. <code>myimage.jpg</code>).</li> <li><code>content_type</code>: An <code>str</code> with the content type (MIME type / media type) or <code>None</code> if it's not available (e.g. <code>image/jpeg</code>).</li> <li><code>file</code>: A <code>SpooledTemporaryFile</code> (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object.</li> <li><code>headers</code>: A <code>Headers</code> object. Often this will only be the <code>Content-Type</code> header, but if additional headers were included in the multipart field they will be included here. Note that these headers have no relationship with the headers in <code>Request.headers</code>.</li> <li><code>size</code>: An <code>int</code> with uploaded file's size in bytes. This value is calculated from request's contents, making it better choice to find uploaded file's size than <code>Content-Length</code> header. <code>None</code> if not set.</li> </ul> <p><code>UploadFile</code> has the following <code>async</code> methods. They all call the corresponding file methods underneath (using the internal <code>SpooledTemporaryFile</code>).</p> <ul> <li><code>async write(data)</code>: Writes <code>data</code> (<code>bytes</code>) to the file.</li> <li><code>async read(size)</code>: Reads <code>size</code> (<code>int</code>) bytes of the file.</li> <li><code>async seek(offset)</code>: Goes to the byte position <code>offset</code> (<code>int</code>) in the file.<ul> <li>E.g., <code>await myfile.seek(0)</code> would go to the start of the file.</li> </ul> </li> <li><code>async close()</code>: Closes the file.</li> </ul> <p>As all these methods are <code>async</code> methods, you need to \"await\" them.</p> <p>For example, you can get the file name and the contents with:</p> <pre><code>async with request.form() as form:\n    filename = form[\"upload_file\"].filename\n    contents = await form[\"upload_file\"].read()\n</code></pre> <p>Info</p> <p>As settled in RFC-7578: 4.2, form-data content part that contains file assumed to have <code>name</code> and <code>filename</code> fields in <code>Content-Disposition</code> header: <code>Content-Disposition: form-data; name=\"user\"; filename=\"somefile\"</code>. Though <code>filename</code> field is optional according to RFC-7578, it helps Starlette to differentiate which data should be treated as file. If <code>filename</code> field was supplied, <code>UploadFile</code> object will be created to access underlying file, otherwise form-data part will be parsed and available as a raw string.</p>"},{"location":"requests/#application","title":"Application","text":"<p>The originating Starlette application can be accessed via <code>request.app</code>.</p>"},{"location":"requests/#other-state","title":"Other state","text":"<p>If you want to store additional information on the request you can do so using <code>request.state</code>.</p> <p>For example:</p> <p><code>request.state.time_started = time.time()</code></p>"},{"location":"responses/","title":"Responses","text":"<p>Starlette includes a few response classes that handle sending back the appropriate ASGI messages on the <code>send</code> channel.</p>"},{"location":"responses/#response","title":"Response","text":"<p>Signature: <code>Response(content, status_code=200, headers=None, media_type=None)</code></p> <ul> <li><code>content</code> - A string or bytestring.</li> <li><code>status_code</code> - An integer HTTP status code.</li> <li><code>headers</code> - A dictionary of strings.</li> <li><code>media_type</code> - A string giving the media type. eg. \"text/html\"</li> </ul> <p>Starlette will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types, unless a charset has already been specified in the <code>media_type</code>.</p> <p>Once you've instantiated a response, you can send it by calling it as an ASGI application instance.</p> <pre><code>from starlette.responses import Response\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = Response('Hello, world!', media_type='text/plain')\n    await response(scope, receive, send)\n</code></pre>"},{"location":"responses/#set-cookie","title":"Set Cookie","text":"<p>Starlette provides a <code>set_cookie</code> method to allow you to set cookies on the response object.</p> <p>Signature: <code>Response.set_cookie(key, value, max_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", partitioned=False)</code></p> <ul> <li><code>key</code> - A string that will be the cookie's key.</li> <li><code>value</code> - A string that will be the cookie's value.</li> <li><code>max_age</code> - An integer that defines the lifetime of the cookie in seconds. A negative integer or a value of <code>0</code> will discard the cookie immediately. <code>Optional</code></li> <li><code>expires</code> - Either an integer that defines the number of seconds until the cookie expires, or a datetime. <code>Optional</code></li> <li><code>path</code> - A string that specifies the subset of routes to which the cookie will apply. <code>Optional</code></li> <li><code>domain</code> - A string that specifies the domain for which the cookie is valid. <code>Optional</code></li> <li><code>secure</code> - A bool indicating that the cookie will only be sent to the server if request is made using SSL and the HTTPS protocol. <code>Optional</code></li> <li><code>httponly</code> - A bool indicating that the cookie cannot be accessed via JavaScript through <code>Document.cookie</code> property, the <code>XMLHttpRequest</code> or <code>Request</code> APIs. <code>Optional</code></li> <li><code>samesite</code> - A string that specifies the samesite strategy for the cookie. Valid values are <code>'lax'</code>, <code>'strict'</code> and <code>'none'</code>. Defaults to <code>'lax'</code>. <code>Optional</code></li> <li><code>partitioned</code> - A bool that indicates to user agents that these cross-site cookies should only be available in the same top-level context that the cookie was first set in. Only available for Python 3.14+, otherwise an error will be raised. <code>Optional</code></li> </ul>"},{"location":"responses/#delete-cookie","title":"Delete Cookie","text":"<p>Conversely, Starlette also provides a <code>delete_cookie</code> method to manually expire a set cookie.</p> <p>Signature: <code>Response.delete_cookie(key, path='/', domain=None)</code></p>"},{"location":"responses/#htmlresponse","title":"HTMLResponse","text":"<p>Takes some text or bytes and returns an HTML response.</p> <pre><code>from starlette.responses import HTMLResponse\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = HTMLResponse('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;')\n    await response(scope, receive, send)\n</code></pre>"},{"location":"responses/#plaintextresponse","title":"PlainTextResponse","text":"<p>Takes some text or bytes and returns a plain text response.</p> <pre><code>from starlette.responses import PlainTextResponse\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = PlainTextResponse('Hello, world!')\n    await response(scope, receive, send)\n</code></pre>"},{"location":"responses/#jsonresponse","title":"JSONResponse","text":"<p>Takes some data and returns an <code>application/json</code> encoded response.</p> <pre><code>from starlette.responses import JSONResponse\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = JSONResponse({'hello': 'world'})\n    await response(scope, receive, send)\n</code></pre>"},{"location":"responses/#custom-json-serialization","title":"Custom JSON serialization","text":"<p>If you need fine-grained control over JSON serialization, you can subclass <code>JSONResponse</code> and override the <code>render</code> method.</p> <p>For example, if you wanted to use a third-party JSON library such as orjson:</p> <pre><code>from typing import Any\n\nimport orjson\nfrom starlette.responses import JSONResponse\n\n\nclass OrjsonResponse(JSONResponse):\n    def render(self, content: Any) -&gt; bytes:\n        return orjson.dumps(content)\n</code></pre> <p>In general you probably want to stick with <code>JSONResponse</code> by default unless you are micro-optimising a particular endpoint or need to serialize non-standard object types.</p>"},{"location":"responses/#redirectresponse","title":"RedirectResponse","text":"<p>Returns an HTTP redirect. Uses a 307 status code by default.</p> <pre><code>from starlette.responses import PlainTextResponse, RedirectResponse\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    if scope['path'] != '/':\n        response = RedirectResponse(url='/')\n    else:\n        response = PlainTextResponse('Hello, world!')\n    await response(scope, receive, send)\n</code></pre>"},{"location":"responses/#streamingresponse","title":"StreamingResponse","text":"<p>Takes an async generator or a normal generator/iterator and streams the response body.</p> <pre><code>from starlette.responses import StreamingResponse\nimport asyncio\n\n\nasync def slow_numbers(minimum, maximum):\n    yield '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'\n    for number in range(minimum, maximum + 1):\n        yield '&lt;li&gt;%d&lt;/li&gt;' % number\n        await asyncio.sleep(0.5)\n    yield '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    generator = slow_numbers(1, 10)\n    response = StreamingResponse(generator, media_type='text/html')\n    await response(scope, receive, send)\n</code></pre> <p>Have in mind that file-like objects (like those created by <code>open()</code>) are normal iterators. So, you can return them directly in a <code>StreamingResponse</code>.</p>"},{"location":"responses/#fileresponse","title":"FileResponse","text":"<p>Asynchronously streams a file as the response.</p> <p>Takes a different set of arguments to instantiate than the other response types:</p> <ul> <li><code>path</code> - The filepath to the file to stream.</li> <li><code>headers</code> - Any custom headers to include, as a dictionary.</li> <li><code>media_type</code> - A string giving the media type. If unset, the filename or path will be used to infer a media type.</li> <li><code>filename</code> - If set, this will be included in the response <code>Content-Disposition</code>.</li> <li><code>content_disposition_type</code> - will be included in the response <code>Content-Disposition</code>. Can be set to \"attachment\" (default) or \"inline\".</li> </ul> <p>File responses will include appropriate <code>Content-Length</code>, <code>Last-Modified</code> and <code>ETag</code> headers.</p> <pre><code>from starlette.responses import FileResponse\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = FileResponse('statics/favicon.ico')\n    await response(scope, receive, send)\n</code></pre> <p>File responses also supports HTTP range requests.</p> <p>The <code>Accept-Ranges: bytes</code> header will be included in the response if the file exists. For now, only the <code>bytes</code> range unit is supported.</p> <p>If the request includes a <code>Range</code> header, and the file exists, the response will be a <code>206 Partial Content</code> response with the requested range of bytes. If the range is invalid, the response will be a <code>416 Range Not Satisfiable</code> response.</p>"},{"location":"responses/#third-party-responses","title":"Third party responses","text":""},{"location":"responses/#eventsourceresponse","title":"EventSourceResponse","text":"<p>A response class that implements Server-Sent Events. It enables event streaming from the server to the client without the complexity of websockets.</p>"},{"location":"routing/","title":"Routing","text":""},{"location":"routing/#http-routing","title":"HTTP Routing","text":"<p>Starlette has a simple but capable request routing system. A routing table is defined as a list of routes, and passed when instantiating the application.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.responses import PlainTextResponse\nfrom starlette.routing import Route\n\n\nasync def homepage(request):\n    return PlainTextResponse(\"Homepage\")\n\nasync def about(request):\n    return PlainTextResponse(\"About\")\n\n\nroutes = [\n    Route(\"/\", endpoint=homepage),\n    Route(\"/about\", endpoint=about),\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>The <code>endpoint</code> argument can be one of:</p> <ul> <li>A regular function or async function, which accepts a single <code>request</code> argument and which should return a response.</li> <li>A class that implements the ASGI interface, such as Starlette's HTTPEndpoint.</li> </ul>"},{"location":"routing/#path-parameters","title":"Path Parameters","text":"<p>Paths can use URI templating style to capture path components.</p> <p><pre><code>Route('/users/{username}', user)\n</code></pre> By default this will capture characters up to the end of the path or the next <code>/</code>.</p> <p>You can use convertors to modify what is captured. The available convertors are:</p> <ul> <li><code>str</code> returns a string, and is the default.</li> <li><code>int</code> returns a Python integer.</li> <li><code>float</code> returns a Python float.</li> <li><code>uuid</code> return a Python <code>uuid.UUID</code> instance.</li> <li><code>path</code> returns the rest of the path, including any additional <code>/</code> characters.</li> </ul> <p>Convertors are used by prefixing them with a colon, like so:</p> <pre><code>Route('/users/{user_id:int}', user)\nRoute('/floating-point/{number:float}', floating_point)\nRoute('/uploaded/{rest_of_path:path}', uploaded)\n</code></pre> <p>If you need a different converter that is not defined, you can create your own. See below an example on how to create a <code>datetime</code> convertor, and how to register it:</p> <pre><code>from datetime import datetime\n\nfrom starlette.convertors import Convertor, register_url_convertor\n\n\nclass DateTimeConvertor(Convertor):\n    regex = \"[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(.[0-9]+)?\"\n\n    def convert(self, value: str) -&gt; datetime:\n        return datetime.strptime(value, \"%Y-%m-%dT%H:%M:%S\")\n\n    def to_string(self, value: datetime) -&gt; str:\n        return value.strftime(\"%Y-%m-%dT%H:%M:%S\")\n\nregister_url_convertor(\"datetime\", DateTimeConvertor())\n</code></pre> <p>After registering it, you'll be able to use it as:</p> <pre><code>Route('/history/{date:datetime}', history)\n</code></pre> <p>Path parameters are made available in the request, as the <code>request.path_params</code> dictionary.</p> <pre><code>async def user(request):\n    user_id = request.path_params['user_id']\n    ...\n</code></pre>"},{"location":"routing/#handling-http-methods","title":"Handling HTTP methods","text":"<p>Routes can also specify which HTTP methods are handled by an endpoint:</p> <pre><code>Route('/users/{user_id:int}', user, methods=[\"GET\", \"POST\"])\n</code></pre> <p>By default function endpoints will only accept <code>GET</code> requests, unless specified.</p>"},{"location":"routing/#submounting-routes","title":"Submounting routes","text":"<p>In large applications you might find that you want to break out parts of the routing table, based on a common path prefix.</p> <pre><code>routes = [\n    Route('/', homepage),\n    Mount('/users', routes=[\n        Route('/', users, methods=['GET', 'POST']),\n        Route('/{username}', user),\n    ])\n]\n</code></pre> <p>This style allows you to define different subsets of the routing table in different parts of your project.</p> <pre><code>from myproject import users, auth\n\nroutes = [\n    Route('/', homepage),\n    Mount('/users', routes=users.routes),\n    Mount('/auth', routes=auth.routes),\n]\n</code></pre> <p>You can also use mounting to include sub-applications within your Starlette application. For example...</p> <pre><code># This is a standalone static files server:\napp = StaticFiles(directory=\"static\")\n\n# This is a static files server mounted within a Starlette application,\n# underneath the \"/static\" path.\nroutes = [\n    ...\n    Mount(\"/static\", app=StaticFiles(directory=\"static\"), name=\"static\")\n]\n\napp = Starlette(routes=routes)\n</code></pre>"},{"location":"routing/#reverse-url-lookups","title":"Reverse URL lookups","text":"<p>You'll often want to be able to generate the URL for a particular route, such as in cases where you need to return a redirect response.</p> <ul> <li>Signature: <code>url_for(name, **path_params) -&gt; URL</code></li> </ul> <pre><code>routes = [\n    Route(\"/\", homepage, name=\"homepage\")\n]\n\n# We can use the following to return a URL...\nurl = request.url_for(\"homepage\")\n</code></pre> <p>URL lookups can include path parameters...</p> <pre><code>routes = [\n    Route(\"/users/{username}\", user, name=\"user_detail\")\n]\n\n# We can use the following to return a URL...\nurl = request.url_for(\"user_detail\", username=...)\n</code></pre> <p>If a <code>Mount</code> includes a <code>name</code>, then submounts should use a <code>{prefix}:{name}</code> style for reverse URL lookups.</p> <pre><code>routes = [\n    Mount(\"/users\", name=\"users\", routes=[\n        Route(\"/\", user, name=\"user_list\"),\n        Route(\"/{username}\", user, name=\"user_detail\")\n    ])\n]\n\n# We can use the following to return URLs...\nurl = request.url_for(\"users:user_list\")\nurl = request.url_for(\"users:user_detail\", username=...)\n</code></pre> <p>Mounted applications may include a <code>path=...</code> parameter.</p> <pre><code>routes = [\n    ...\n    Mount(\"/static\", app=StaticFiles(directory=\"static\"), name=\"static\")\n]\n\n# We can use the following to return URLs...\nurl = request.url_for(\"static\", path=\"/css/base.css\")\n</code></pre> <p>For cases where there is no <code>request</code> instance, you can make reverse lookups against the application, although these will only return the URL path.</p> <pre><code>url = app.url_path_for(\"user_detail\", username=...)\n</code></pre>"},{"location":"routing/#host-based-routing","title":"Host-based routing","text":"<p>If you want to use different routes for the same path based on the <code>Host</code> header.</p> <p>Note that port is removed from the <code>Host</code> header when matching. For example, <code>Host (host='example.org:3600', ...)</code> will be processed even if the <code>Host</code> header contains or does not contain a port other than <code>3600</code> (<code>example.org:5600</code>, <code>example.org</code>). Therefore, you can specify the port if you need it for use in <code>url_for</code>.</p> <p>There are several ways to connect host-based routes to your application</p> <pre><code>site = Router()  # Use eg. `@site.route()` to configure this.\napi = Router()  # Use eg. `@api.route()` to configure this.\nnews = Router()  # Use eg. `@news.route()` to configure this.\n\nroutes = [\n    Host('api.example.org', api, name=\"site_api\")\n]\n\napp = Starlette(routes=routes)\n\napp.host('www.example.org', site, name=\"main_site\")\n\nnews_host = Host('news.example.org', news)\napp.router.routes.append(news_host)\n</code></pre> <p>URL lookups can include host parameters just like path parameters</p> <pre><code>routes = [\n    Host(\"{subdomain}.example.org\", name=\"sub\", app=Router(routes=[\n        Mount(\"/users\", name=\"users\", routes=[\n            Route(\"/\", user, name=\"user_list\"),\n            Route(\"/{username}\", user, name=\"user_detail\")\n        ])\n    ]))\n]\n...\nurl = request.url_for(\"sub:users:user_detail\", username=..., subdomain=...)\nurl = request.url_for(\"sub:users:user_list\", subdomain=...)\n</code></pre>"},{"location":"routing/#route-priority","title":"Route priority","text":"<p>Incoming paths are matched against each <code>Route</code> in order.</p> <p>In cases where more that one route could match an incoming path, you should take care to ensure that more specific routes are listed before general cases.</p> <p>For example:</p> <pre><code># Don't do this: `/users/me` will never match incoming requests.\nroutes = [\n    Route('/users/{username}', user),\n    Route('/users/me', current_user),\n]\n\n# Do this: `/users/me` is tested first.\nroutes = [\n    Route('/users/me', current_user),\n    Route('/users/{username}', user),\n]\n</code></pre>"},{"location":"routing/#working-with-router-instances","title":"Working with Router instances","text":"<p>If you're working at a low-level you might want to use a plain <code>Router</code> instance, rather that creating a <code>Starlette</code> application. This gives you a lightweight ASGI application that just provides the application routing, without wrapping it up in any middleware.</p> <pre><code>app = Router(routes=[\n    Route('/', homepage),\n    Mount('/users', routes=[\n        Route('/', users, methods=['GET', 'POST']),\n        Route('/{username}', user),\n    ])\n])\n</code></pre>"},{"location":"routing/#websocket-routing","title":"WebSocket Routing","text":"<p>When working with WebSocket endpoints, you should use <code>WebSocketRoute</code> instead of the usual <code>Route</code>.</p> <p>Path parameters, and reverse URL lookups for <code>WebSocketRoute</code> work the the same as HTTP <code>Route</code>, which can be found in the HTTP Route section above.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import WebSocketRoute\n\n\nasync def websocket_index(websocket):\n    await websocket.accept()\n    await websocket.send_text(\"Hello, websocket!\")\n    await websocket.close()\n\n\nasync def websocket_user(websocket):\n    name = websocket.path_params[\"name\"]\n    await websocket.accept()\n    await websocket.send_text(f\"Hello, {name}\")\n    await websocket.close()\n\n\nroutes = [\n    WebSocketRoute(\"/\", endpoint=websocket_index),\n    WebSocketRoute(\"/{name}\", endpoint=websocket_user),\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>The <code>endpoint</code> argument can be one of:</p> <ul> <li>An async function, which accepts a single <code>websocket</code> argument.</li> <li>A class that implements the ASGI interface, such as Starlette's WebSocketEndpoint.</li> </ul>"},{"location":"schemas/","title":"API Schemas","text":"<p>Starlette supports generating API schemas, such as the widely used OpenAPI specification. (Formerly known as \"Swagger\".)</p> <p>Schema generation works by inspecting the routes on the application through <code>app.routes</code>, and using the docstrings or other attributes on the endpoints in order to determine a complete API schema.</p> <p>Starlette is not tied to any particular schema generation or validation tooling, but includes a simple implementation that generates OpenAPI schemas based on the docstrings.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import Route\nfrom starlette.schemas import SchemaGenerator\n\n\nschemas = SchemaGenerator(\n    {\"openapi\": \"3.0.0\", \"info\": {\"title\": \"Example API\", \"version\": \"1.0\"}}\n)\n\ndef list_users(request):\n    \"\"\"\n    responses:\n      200:\n        description: A list of users.\n        examples:\n          [{\"username\": \"tom\"}, {\"username\": \"lucy\"}]\n    \"\"\"\n    raise NotImplementedError()\n\n\ndef create_user(request):\n    \"\"\"\n    responses:\n      200:\n        description: A user.\n        examples:\n          {\"username\": \"tom\"}\n    \"\"\"\n    raise NotImplementedError()\n\n\ndef openapi_schema(request):\n    return schemas.OpenAPIResponse(request=request)\n\n\nroutes = [\n    Route(\"/users\", endpoint=list_users, methods=[\"GET\"]),\n    Route(\"/users\", endpoint=create_user, methods=[\"POST\"]),\n    Route(\"/schema\", endpoint=openapi_schema, include_in_schema=False)\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>We can now access an OpenAPI schema at the \"/schema\" endpoint.</p> <p>You can generate the API Schema directly with <code>.get_schema(routes)</code>:</p> <pre><code>schema = schemas.get_schema(routes=app.routes)\nassert schema == {\n    \"openapi\": \"3.0.0\",\n    \"info\": {\"title\": \"Example API\", \"version\": \"1.0\"},\n    \"paths\": {\n        \"/users\": {\n            \"get\": {\n                \"responses\": {\n                    200: {\n                        \"description\": \"A list of users.\",\n                        \"examples\": [{\"username\": \"tom\"}, {\"username\": \"lucy\"}],\n                    }\n                }\n            },\n            \"post\": {\n                \"responses\": {\n                    200: {\"description\": \"A user.\", \"examples\": {\"username\": \"tom\"}}\n                }\n            },\n        },\n    },\n}\n</code></pre> <p>You might also want to be able to print out the API schema, so that you can use tooling such as generating API documentation.</p> <pre><code>if __name__ == '__main__':\n    assert sys.argv[-1] in (\"run\", \"schema\"), \"Usage: example.py [run|schema]\"\n\n    if sys.argv[-1] == \"run\":\n        uvicorn.run(\"example:app\", host='0.0.0.0', port=8000)\n    elif sys.argv[-1] == \"schema\":\n        schema = schemas.get_schema(routes=app.routes)\n        print(yaml.dump(schema, default_flow_style=False))\n</code></pre>"},{"location":"schemas/#third-party-packages","title":"Third party packages","text":""},{"location":"schemas/#starlette-apispec","title":"starlette-apispec","text":"<p>Easy APISpec integration for Starlette, which supports some object serialization libraries.</p>"},{"location":"server-push/","title":"Server Push","text":"<p>Starlette includes support for HTTP/2 and HTTP/3 server push, making it possible to push resources to the client to speed up page load times.</p>"},{"location":"server-push/#requestsend_push_promise","title":"<code>Request.send_push_promise</code>","text":"<p>Used to initiate a server push for a resource. If server push is not available this method does nothing.</p> <p>Signature: <code>send_push_promise(path)</code></p> <ul> <li><code>path</code> - A string denoting the path of the resource.</li> </ul> <pre><code>from starlette.applications import Starlette\nfrom starlette.responses import HTMLResponse\nfrom starlette.routing import Route, Mount\nfrom starlette.staticfiles import StaticFiles\n\n\nasync def homepage(request):\n    \"\"\"\n    Homepage which uses server push to deliver the stylesheet.\n    \"\"\"\n    await request.send_push_promise(\"/static/style.css\")\n    return HTMLResponse(\n        '&lt;html&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" href=\"/static/style.css\"/&gt;&lt;/head&gt;&lt;/html&gt;'\n    )\n\nroutes = [\n    Route(\"/\", endpoint=homepage),\n    Mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\")\n]\n\napp = Starlette(routes=routes)\n</code></pre>"},{"location":"sponsorship/","title":"\u2728 Sponsor Starlette &amp; Uvicorn \u2728","text":"<p>Thank you for your interest in sponsoring Starlette and Uvicorn! \u2764\ufe0f</p> <p>Your support directly contributes to the ongoing development, maintenance, and long-term sustainability of both projects.</p> 67M+ <p>Starlette Downloads/Month</p> 57M+ <p>Uvicorn Downloads/Month</p> 19K+ <p>Combined GitHub Stars</p>"},{"location":"sponsorship/#why-sponsor","title":"Why Sponsor?","text":"<p>While Starlette and Uvicorn are part of the Encode organization, they have been primarily maintained by Marcelo Trylesinski (Kludex) for the past several years. His dedication and consistent work have been instrumental in keeping these projects robust, secure, and up-to-date.</p> <p>This sponsorship page was created to give the community an opportunity to support Marcelo's continued efforts in maintaining and improving both projects. Your sponsorship directly enables him to dedicate more time and resources to maintaining and improving these essential tools:</p> <ul> <li> Active Development: Developing new features, enhancing existing ones, and   keeping both projects aligned with the latest developments in the Python and ASGI ecosystems. \ud83d\udcbb</li> <li> Community Support: Providing better support, addressing user issues,   and cultivating a welcoming environment for contributors. \ud83e\udd1d</li> <li> Long-Term Stability: Ensuring the long-term viability of both projects through strategic   planning and addressing technical debt. \ud83c\udf33</li> <li> Bug Fixes &amp; Maintenance: Providing prompt attention to bug reports and   general maintenance to keep the projects reliable. \ud83d\udd28</li> <li> Security: Ensuring robust security practices, conducting regular security audits, and   promptly addressing vulnerabilities to protect millions of production deployments. \ud83d\udd12</li> <li> Documentation: Creating comprehensive guides, tutorials, and examples to help users of all skill levels. \ud83d\udcd6</li> </ul>"},{"location":"sponsorship/#how-sponsorship-works","title":"How Sponsorship Works\ud83c\udf1f Become a Sponsor Today! \ud83c\udf1f","text":"<p>We currently manage sponsorships exclusively through GitHub Sponsors. This platform integrates seamlessly with the GitHub ecosystem, making it easy for organizations to contribute.</p> <p>Your support helps keep Starlette and Uvicorn growing stronger!</p>          \u2764\ufe0f Sponsor on GitHub"},{"location":"sponsorship/#sponsorship-tiers","title":"Sponsorship Tiers \ud83c\udf81","text":"\ud83e\udd49 Bronze Sponsor $100/month <ul> <li>\u2713 Company name on Sponsors page</li> <li>\u2713 Small logo with link</li> <li>\u2713 Our eternal gratitude</li> </ul>                  Become a Bronze Sponsor              \ud83e\udd48 Silver Sponsor $250/month <ul> <li>\u2713 All Bronze benefits</li> <li>\u2713 Medium-sized logo</li> <li>\u2713 Release notes mention</li> </ul>                  Become a Silver Sponsor                           Popular          \ud83e\udd47 Gold Sponsor $500/month <ul> <li>\u2713 All Silver benefits</li> <li>\u2713 Large logo on main pages</li> <li>\u2713 Priority support</li> </ul>                  Become a Gold Sponsor              \ud83e\udd1d Custom Sponsor <p>Looking for something different? Contact us to discuss custom sponsorship options!</p>"},{"location":"sponsorship/#current-sponsors","title":"Current Sponsors","text":"<p>Thank you to our generous sponsors! \ud83d\ude4f</p> \ud83c\udfc6 Gold Sponsors <p>Modern, fast web framework for building APIs with Python 3.8+</p> \ud83e\udd48 Silver Sponsors \ud83e\udd49 Bronze Sponsors"},{"location":"sponsorship/#alternative-sponsorship-platforms","title":"Alternative Sponsorship Platforms","text":"\ud83d\udce2 We Want Your Input! <p>We are currently evaluating whether to expand our sponsorship options beyond GitHub Sponsors. If your company would be interested in sponsoring Starlette and Uvicorn but prefers to use a different platform (e.g., Open Collective, direct invoicing), please let us know!</p> <p>Your feedback is invaluable in helping us make sponsorship as accessible as possible. Share your thoughts by:</p> <ul> <li>Opening a discussion on our GitHub repository</li> <li>Contacting us directly at marcelotryle@gmail.com</li> </ul> <p></p>"},{"location":"sponsorship/#community-future-plans","title":"Community &amp; Future Plans \ud83c\udf1f","text":"<p>We want to express our deepest gratitude to all the contributors who have helped shape Starlette and Uvicorn over the years. These projects wouldn't be what they are today without the incredible work of every single contributor.</p> <p>Special thanks to some of our most impactful contributors:</p> <ul> <li>Tom Christie (@tomchristie) - The original creator of Starlette and Uvicorn.</li> <li>Adrian Garcia Badaracco (@adriangb) - Major contributor to Starlette.</li> <li>Thomas Grainger (@graingert) - Major contributor to AnyIO, and significant contributions to Starlette and Uvicorn.</li> <li>Alex Gr\u00f6nholm (@agronholm) - Creator of AnyIO.</li> <li>Florimond Manca (@florimondmanca) - Important contributions to Starlette and Uvicorn.</li> </ul> <p>If you want your name removed from the list above, or if I forgot a significant contributor, please let me know. You can view all contributors on GitHub: Starlette Contributors / Uvicorn Contributors.</p> <p>While the current sponsorship program directly supports Marcelo's maintenance work, we are exploring ways to distribute funding to other key contributors in the future. This initiative is still in early planning stages, as we want to ensure a fair and sustainable model that recognizes the valuable contributions of our community members.</p>"},{"location":"staticfiles/","title":"Static Files","text":"<p>Starlette also includes a <code>StaticFiles</code> class for serving files in a given directory:</p>"},{"location":"staticfiles/#staticfiles","title":"StaticFiles","text":"<p>Signature: <code>StaticFiles(directory=None, packages=None, html=False, check_dir=True, follow_symlink=False)</code></p> <ul> <li><code>directory</code> - A string or os.PathLike denoting a directory path.</li> <li><code>packages</code> - A list of strings or list of tuples of strings of python packages.</li> <li><code>html</code> - Run in HTML mode. Automatically loads <code>index.html</code> for directories if such file exist.</li> <li><code>check_dir</code> - Ensure that the directory exists upon instantiation. Defaults to <code>True</code>.</li> <li><code>follow_symlink</code> - A boolean indicating if symbolic links for files and directories should be followed. Defaults to <code>False</code>.</li> </ul> <p>You can combine this ASGI application with Starlette's routing to provide comprehensive static file serving.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import Mount\nfrom starlette.staticfiles import StaticFiles\n\n\nroutes = [\n    ...\n    Mount('/static', app=StaticFiles(directory='static'), name=\"static\"),\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>Static files will respond with \"404 Not found\" or \"405 Method not allowed\" responses for requests which do not match. In HTML mode if <code>404.html</code> file exists it will be shown as 404 response.</p> <p>The <code>packages</code> option can be used to include \"static\" directories contained within a python package. The Python \"bootstrap4\" package is an example of this.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import Mount\nfrom starlette.staticfiles import StaticFiles\n\n\nroutes=[\n    ...\n    Mount('/static', app=StaticFiles(directory='static', packages=['bootstrap4']), name=\"static\"),\n]\n\napp = Starlette(routes=routes)\n</code></pre> <p>By default <code>StaticFiles</code> will look for <code>statics</code> directory in each package, you can change the default directory by specifying a tuple of strings.</p> <pre><code>routes=[\n    ...\n    Mount('/static', app=StaticFiles(packages=[('bootstrap4', 'static')]), name=\"static\"),\n]\n</code></pre> <p>You may prefer to include static files directly inside the \"static\" directory rather than using Python packaging to include static files, but it can be useful for bundling up reusable components.</p>"},{"location":"templates/","title":"Templates","text":"<p>Starlette is not strictly coupled to any particular templating engine, but Jinja2 provides an excellent choice.</p>"},{"location":"templates/#jinja2templates","title":"Jinja2Templates","text":"<p>Signature: <code>Jinja2Templates(directory, context_processors=None, **env_options)</code></p> <ul> <li><code>directory</code> - A string, os.Pathlike or a list of strings or os.Pathlike denoting a directory path.</li> <li><code>context_processors</code> - A list of functions that return a dictionary to add to the template context.</li> <li><code>**env_options</code> - Additional keyword arguments to pass to the Jinja2 environment.</li> </ul> <p>Starlette provides a simple way to get <code>jinja2</code> configured. This is probably what you want to use by default.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import Route, Mount\nfrom starlette.templating import Jinja2Templates\nfrom starlette.staticfiles import StaticFiles\n\n\ntemplates = Jinja2Templates(directory='templates')\n\nasync def homepage(request):\n    return templates.TemplateResponse(request, 'index.html')\n\nroutes = [\n    Route('/', endpoint=homepage),\n    Mount('/static', StaticFiles(directory='static'), name='static')\n]\n\napp = Starlette(debug=True, routes=routes)\n</code></pre> <p>Note that the incoming <code>request</code> instance must be included as part of the template context.</p> <p>The Jinja2 template context will automatically include a <code>url_for</code> function, so we can correctly hyperlink to other pages within the application.</p> <p>For example, we can link to static files from within our HTML templates:</p> <pre><code>&lt;link href=\"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel=\"stylesheet\" /&gt;\n</code></pre> <p>If you want to use custom filters, you will need to update the <code>env</code> property of <code>Jinja2Templates</code>:</p> <pre><code>from commonmark import commonmark\nfrom starlette.templating import Jinja2Templates\n\ndef marked_filter(text):\n    return commonmark(text)\n\ntemplates = Jinja2Templates(directory='templates')\ntemplates.env.filters['marked'] = marked_filter\n</code></pre>"},{"location":"templates/#using-custom-jinja2environment-instance","title":"Using custom jinja2.Environment instance","text":"<p>Starlette also accepts a preconfigured <code>jinja2.Environment</code> instance. </p> <pre><code>import jinja2\nfrom starlette.templating import Jinja2Templates\n\nenv = jinja2.Environment(...)\ntemplates = Jinja2Templates(env=env)\n</code></pre>"},{"location":"templates/#context-processors","title":"Context processors","text":"<p>A context processor is a function that returns a dictionary to be merged into a template context. Every function takes only one argument <code>request</code> and must return a dictionary to add to the context.</p> <p>A common use case of template processors is to extend the template context with shared variables.</p> <pre><code>import typing\nfrom starlette.requests import Request\n\ndef app_context(request: Request) -&gt; typing.Dict[str, typing.Any]:\n    return {'app': request.app}\n</code></pre>"},{"location":"templates/#registering-context-templates","title":"Registering context templates","text":"<p>Pass context processors to <code>context_processors</code> argument of the <code>Jinja2Templates</code> class.</p> <pre><code>import typing\n\nfrom starlette.requests import Request\nfrom starlette.templating import Jinja2Templates\n\ndef app_context(request: Request) -&gt; typing.Dict[str, typing.Any]:\n    return {'app': request.app}\n\ntemplates = Jinja2Templates(\n    directory='templates', context_processors=[app_context]\n)\n</code></pre> <p>Info</p> <p>Asynchronous functions as context processors are not supported.</p>"},{"location":"templates/#testing-template-responses","title":"Testing template responses","text":"<p>When using the test client, template responses include <code>.template</code> and <code>.context</code> attributes.</p> <pre><code>from starlette.testclient import TestClient\n\n\ndef test_homepage():\n    client = TestClient(app)\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.template.name == 'index.html'\n    assert \"request\" in response.context\n</code></pre>"},{"location":"templates/#customizing-jinja2-environment","title":"Customizing Jinja2 Environment","text":"<p><code>Jinja2Templates</code> accepts all options supported by Jinja2 <code>Environment</code>. This will allow more control over the <code>Environment</code> instance created by Starlette.</p> <p>For the list of options available to <code>Environment</code> you can check Jinja2 documentation here</p> <pre><code>from starlette.templating import Jinja2Templates\n\n\ntemplates = Jinja2Templates(directory='templates', autoescape=False, auto_reload=True)\n</code></pre>"},{"location":"templates/#asynchronous-template-rendering","title":"Asynchronous template rendering","text":"<p>Jinja2 supports async template rendering, however as a general rule we'd recommend that you keep your templates free from logic that invokes database lookups, or other I/O operations.</p> <p>Instead we'd recommend that you ensure that your endpoints perform all I/O, for example, strictly evaluate any database queries within the view and include the final results in the context.</p>"},{"location":"testclient/","title":"Test Client","text":"API Reference <p>The test client allows you to make requests against your ASGI application, using the <code>httpx</code> library.</p> <pre><code>from starlette.responses import HTMLResponse\nfrom starlette.testclient import TestClient\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'http'\n    response = HTMLResponse('&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;')\n    await response(scope, receive, send)\n\n\ndef test_app():\n    client = TestClient(app)\n    response = client.get('/')\n    assert response.status_code == 200\n</code></pre> <p>The test client exposes the same interface as any other <code>httpx</code> session. In particular, note that the calls to make a request are just standard function calls, not awaitables.</p> <p>You can use any of <code>httpx</code> standard API, such as authentication, session cookies handling, or file uploads.</p> <p>For example, to set headers on the TestClient you can do:</p> <pre><code>client = TestClient(app)\n\n# Set headers on the client for future requests\nclient.headers = {\"Authorization\": \"...\"}\nresponse = client.get(\"/\")\n\n# Set headers for each request separately\nresponse = client.get(\"/\", headers={\"Authorization\": \"...\"})\n</code></pre> <p>And for example to send files with the TestClient:</p> <pre><code>client = TestClient(app)\n\n# Send a single file\nwith open(\"example.txt\", \"rb\") as f:\n    response = client.post(\"/form\", files={\"file\": f})\n\n# Send multiple files\nwith open(\"example.txt\", \"rb\") as f1:\n    with open(\"example.png\", \"rb\") as f2:\n        files = {\"file1\": f1, \"file2\": (\"filename\", f2, \"image/png\")}\n        response = client.post(\"/form\", files=files)\n</code></pre> <p>For more information you can check the <code>httpx</code> documentation.</p> <p>By default the <code>TestClient</code> will raise any exceptions that occur in the application. Occasionally you might want to test the content of 500 error responses, rather than allowing client to raise the server exception. In this case you should use <code>client = TestClient(app, raise_server_exceptions=False)</code>.</p> <p>Note</p> <p>If you want the <code>TestClient</code> to run the <code>lifespan</code> handler, you will need to use the <code>TestClient</code> as a context manager. It will not be triggered when the <code>TestClient</code> is instantiated. You can learn more about it here.</p>"},{"location":"testclient/#starlette.testclient.TestClient","title":"starlette.testclient.TestClient","text":"<pre><code>TestClient(\n    app: ASGIApp,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    backend: Literal[\"asyncio\", \"trio\"] = \"asyncio\",\n    backend_options: dict[str, Any] | None = None,\n    cookies: CookieTypes | None = None,\n    headers: dict[str, str] | None = None,\n    follow_redirects: bool = True,\n    client: tuple[str, int] = (\"testclient\", 50000),\n)\n</code></pre>"},{"location":"testclient/#change-client-address","title":"Change client address","text":"<p>By default, the TestClient will set the client host to <code>\"testserver\"</code> and the port to <code>50000</code>.</p> <p>You can change the client address by setting the <code>client</code> attribute of the <code>TestClient</code> instance:</p> <pre><code>client = TestClient(app, client=('localhost', 8000))\n</code></pre>"},{"location":"testclient/#selecting-the-async-backend","title":"Selecting the Async backend","text":"<p><code>TestClient</code> takes arguments <code>backend</code> (a string) and <code>backend_options</code> (a dictionary). These options are passed to <code>anyio.start_blocking_portal()</code>. See the anyio documentation for more information about the accepted backend options. By default, <code>asyncio</code> is used with default options.</p> <p>To run <code>Trio</code>, pass <code>backend=\"trio\"</code>. For example:</p> <pre><code>def test_app()\n    with TestClient(app, backend=\"trio\") as client:\n       ...\n</code></pre> <p>To run <code>asyncio</code> with <code>uvloop</code>, pass <code>backend_options={\"use_uvloop\": True}</code>.  For example:</p> <pre><code>def test_app()\n    with TestClient(app, backend_options={\"use_uvloop\": True}) as client:\n       ...\n</code></pre>"},{"location":"testclient/#testing-websocket-sessions","title":"Testing WebSocket sessions","text":"<p>You can also test websocket sessions with the test client.</p> <p>The <code>httpx</code> library will be used to build the initial handshake, meaning you can use the same authentication options and other headers between both http and websocket testing.</p> <pre><code>from starlette.testclient import TestClient\nfrom starlette.websockets import WebSocket\n\n\nasync def app(scope, receive, send):\n    assert scope['type'] == 'websocket'\n    websocket = WebSocket(scope, receive=receive, send=send)\n    await websocket.accept()\n    await websocket.send_text('Hello, world!')\n    await websocket.close()\n\n\ndef test_app():\n    client = TestClient(app)\n    with client.websocket_connect('/') as websocket:\n        data = websocket.receive_text()\n        assert data == 'Hello, world!'\n</code></pre> <p>The operations on session are standard function calls, not awaitables.</p> <p>It's important to use the session within a context-managed <code>with</code> block. This ensure that the background thread on which the ASGI application is properly terminated, and that any exceptions that occur within the application are always raised by the test client.</p>"},{"location":"testclient/#establishing-a-test-session","title":"Establishing a test session","text":"<ul> <li><code>.websocket_connect(url, subprotocols=None, **options)</code> - Takes the same set of arguments as <code>httpx.get()</code>.</li> </ul> <p>May raise <code>starlette.websockets.WebSocketDisconnect</code> if the application does not accept the websocket connection.</p> <p><code>websocket_connect()</code> must be used as a context manager (in a <code>with</code> block).</p> <p>Note</p> <p>The <code>params</code> argument is not supported by <code>websocket_connect</code>. If you need to pass query arguments, hard code it directly in the URL.</p> <pre><code>with client.websocket_connect('/path?foo=bar') as websocket:\n    ...\n</code></pre>"},{"location":"testclient/#sending-data","title":"Sending data","text":"<ul> <li><code>.send_text(data)</code> - Send the given text to the application.</li> <li><code>.send_bytes(data)</code> - Send the given bytes to the application.</li> <li><code>.send_json(data, mode=\"text\")</code> - Send the given data to the application. Use <code>mode=\"binary\"</code> to send JSON over binary data frames.</li> </ul>"},{"location":"testclient/#receiving-data","title":"Receiving data","text":"<ul> <li><code>.receive_text()</code> - Wait for incoming text sent by the application and return it.</li> <li><code>.receive_bytes()</code> - Wait for incoming bytestring sent by the application and return it.</li> <li><code>.receive_json(mode=\"text\")</code> - Wait for incoming json data sent by the application and return it. Use <code>mode=\"binary\"</code> to receive JSON over binary data frames.</li> </ul> <p>May raise <code>starlette.websockets.WebSocketDisconnect</code>.</p>"},{"location":"testclient/#closing-the-connection","title":"Closing the connection","text":"<ul> <li><code>.close(code=1000)</code> - Perform a client-side close of the websocket connection.</li> </ul>"},{"location":"testclient/#asynchronous-tests","title":"Asynchronous tests","text":"<p>Sometimes you will want to do async things outside of your application. For example, you might want to check the state of your database after calling your app using your existing async database client/infrastructure.</p> <p>For these situations, using <code>TestClient</code> is difficult because it creates it's own event loop and async resources (like a database connection) often cannot be shared across event loops. The simplest way to work around this is to just make your entire test async and use an async client, like httpx.AsyncClient.</p> <p>Here is an example of such a test:</p> <pre><code>from httpx import AsyncClient, ASGITransport\nfrom starlette.applications import Starlette\nfrom starlette.routing import Route\nfrom starlette.requests import Request\nfrom starlette.responses import PlainTextResponse\n\n\ndef hello(request: Request) -&gt; PlainTextResponse:\n    return PlainTextResponse(\"Hello World!\")\n\n\napp = Starlette(routes=[Route(\"/\", hello)])\n\n\n# if you're using pytest, you'll need to to add an async marker like:\n# @pytest.mark.anyio  # using https://github.com/agronholm/anyio\n# or install and configure pytest-asyncio (https://github.com/pytest-dev/pytest-asyncio)\nasync def test_app() -&gt; None:\n    # note: you _must_ set `base_url` for relative urls like \"/\" to work\n    transport = ASGITransport(app=app)\n    async with AsyncClient(transport=transport, base_url=\"http://testserver\") as client:\n        r = await client.get(\"/\")\n        assert r.status_code == 200\n        assert r.text == \"Hello World!\"\n</code></pre>"},{"location":"third-party-packages/","title":"Third Party Packages","text":"<p>Starlette has a rapidly growing community of developers, building tools that integrate into Starlette, tools that depend on Starlette, etc.</p> <p>Here are some of those third party packages:</p>"},{"location":"third-party-packages/#plugins","title":"Plugins","text":""},{"location":"third-party-packages/#apitally","title":"Apitally","text":"<p>GitHub | Documentation</p> <p>Analytics, request logging and monitoring for REST APIs built with Starlette (and other frameworks).</p>"},{"location":"third-party-packages/#authlib","title":"Authlib","text":"<p>GitHub | Documentation</p> <p>The ultimate Python library in building OAuth and OpenID Connect clients and servers. Check out how to integrate with Starlette.</p>"},{"location":"third-party-packages/#channelbox","title":"ChannelBox","text":"<p>GitHub</p> <p>Another solution for websocket broadcast. Send messages to channel groups from any part of your code. Checkout MySimpleChat, a simple chat application built using <code>channel-box</code> and <code>starlette</code>.</p>"},{"location":"third-party-packages/#imia","title":"Imia","text":"<p>GitHub</p> <p>An authentication framework for Starlette with pluggable authenticators and login/logout flow.</p>"},{"location":"third-party-packages/#mangum","title":"Mangum","text":"<p>GitHub</p> <p>Serverless ASGI adapter for AWS Lambda &amp; API Gateway.</p>"},{"location":"third-party-packages/#nejma","title":"Nejma","text":"<p>GitHub</p> <p>Manage and send messages to groups of channels using websockets. Checkout nejma-chat, a simple chat application built using <code>nejma</code> and <code>starlette</code>.</p>"},{"location":"third-party-packages/#scout-apm","title":"Scout APM","text":"<p>GitHub</p> <p>An APM (Application Performance Monitoring) solution that can instrument your application to find performance bottlenecks.</p>"},{"location":"third-party-packages/#spectree","title":"SpecTree","text":"<p>GitHub</p> <p>Generate OpenAPI spec document and validate request &amp; response with Python annotations. Less boilerplate code(no need for YAML).</p>"},{"location":"third-party-packages/#starlette-apispec","title":"Starlette APISpec","text":"<p>GitHub</p> <p>Simple APISpec integration for Starlette. Document your REST API built with Starlette by declaring OpenAPI (Swagger) schemas in YAML format in your endpoint's docstrings.</p>"},{"location":"third-party-packages/#starlette-compress","title":"Starlette Compress","text":"<p>GitHub</p> <p>Starlette-Compress is a fast and simple middleware for compressing responses in Starlette. It adds ZStd, Brotli, and GZip compression support with sensible default configuration.</p>"},{"location":"third-party-packages/#starlette-context","title":"Starlette Context","text":"<p>GitHub</p> <p>Middleware for Starlette that allows you to store and access the context data of a request. Can be used with logging so logs automatically use request headers such as x-request-id or x-correlation-id.</p>"},{"location":"third-party-packages/#starlette-cramjam","title":"Starlette Cramjam","text":"<p>GitHub</p> <p>A Starlette middleware that allows brotli, gzip and deflate compression algorithm with a minimal requirements.</p>"},{"location":"third-party-packages/#starlette-oauth2-api","title":"Starlette OAuth2 API","text":"<p>GitLab</p> <p>A starlette middleware to add authentication and authorization through JWTs. It relies solely on an auth provider to issue access and/or id tokens to clients.</p>"},{"location":"third-party-packages/#starlette-prometheus","title":"Starlette Prometheus","text":"<p>GitHub</p> <p>A plugin for providing an endpoint that exposes Prometheus metrics based on its official python client.</p>"},{"location":"third-party-packages/#starlette-wtf","title":"Starlette WTF","text":"<p>GitHub</p> <p>A simple tool for integrating Starlette and WTForms. It is modeled on the excellent Flask-WTF library.</p>"},{"location":"third-party-packages/#starlette-login","title":"Starlette-Login","text":"<p>GitHub | Documentation</p> <p>User session management for Starlette. It handles the common tasks of logging in, logging out, and remembering your users' sessions over extended periods of time.</p>"},{"location":"third-party-packages/#starsessions","title":"Starsessions","text":"<p>GitHub</p> <p>An alternate session support implementation with customizable storage backends.</p>"},{"location":"third-party-packages/#webargs-starlette","title":"webargs-starlette","text":"<p>GitHub</p> <p>Declarative request parsing and validation for Starlette, built on top of webargs.</p> <p>Allows you to parse querystring, JSON, form, headers, and cookies using type annotations.</p>"},{"location":"third-party-packages/#decorouter","title":"DecoRouter","text":"<p>GitHub</p> <p>FastAPI style routing for Starlette.</p> <p>Allows you to use decorators to generate routing tables.</p>"},{"location":"third-party-packages/#starception","title":"Starception","text":"<p>GitHub</p> <p>Beautiful exception page for Starlette apps.</p>"},{"location":"third-party-packages/#starlette-admin","title":"Starlette-Admin","text":"<p>GitHub | Documentation</p> <p>Simple and extensible admin interface framework.</p> <p>Built with Tabler and Datatables, it allows you to quickly generate fully customizable admin interface for your models. You can export your data to many formats (CSV, PDF, Excel, etc), filter your data with complex query including <code>AND</code> and <code>OR</code> conditions,  upload files, ...</p>"},{"location":"third-party-packages/#vellox","title":"Vellox","text":"<p>GitHub</p> <p>Serverless ASGI adapter for GCP Cloud Functions.</p>"},{"location":"third-party-packages/#starlette-bridge","title":"Starlette Bridge","text":"<p>GitHub | Documentation</p> <p>With the deprecation of <code>on_startup</code> and <code>on_shutdown</code>, Starlette Bridge makes sure you can still use the old ways of declaring events with a particularity that internally, in fact, creates the <code>lifespan</code> for you. This way backwards compatibility is assured for the existing packages out there while maintaining the integrity of the newly <code>lifespan</code> events of <code>Starlette</code>.</p>"},{"location":"third-party-packages/#frameworks","title":"Frameworks","text":""},{"location":"third-party-packages/#fastapi","title":"FastAPI","text":"<p>GitHub | Documentation</p> <p>High performance, easy to learn, fast to code, ready for production web API framework. Inspired by APIStar's previous server system with type declarations for route parameters, based on the OpenAPI specification version 3.0.0+ (with JSON Schema), powered by Pydantic for the data handling.</p>"},{"location":"third-party-packages/#flama","title":"Flama","text":"<p>GitHub | Documentation</p> <p>Flama is a data-science oriented framework to rapidly build modern and robust machine learning (ML) APIs. The main aim of the framework is to make ridiculously simple the deployment of ML APIs. With Flama, data scientists can now quickly turn their ML models into asynchronous, auto-documented APIs with just a single line of code. All in just few seconds!</p> <p>Flama comes with an intuitive CLI, and provides an easy-to-learn philosophy to speed up the building of highly performant GraphQL, REST, and ML APIs. Besides, it comprises an ideal solution for the development of asynchronous and production-ready services, offering automatic deployment for ML models.</p>"},{"location":"third-party-packages/#greppo","title":"Greppo","text":"<p>GitHub | Documentation</p> <p>A Python framework for building geospatial dashboards and web-applications.</p> <p>Greppo is an open-source Python framework that makes it easy to build geospatial dashboards and web-applications. It provides a toolkit to quickly integrate data, algorithms, visualizations and UI for interactivity. It provides APIs to the update the variables in the backend, recompute the logic, and reflect the changes in the frontend (data mutation hook).</p>"},{"location":"third-party-packages/#responder","title":"Responder","text":"<p>GitHub | Documentation</p> <p>Async web service framework. Some Features: flask-style route expression, yaml support, OpenAPI schema generation, background tasks, graphql.</p>"},{"location":"third-party-packages/#starlette-apps","title":"Starlette-apps","text":"<p>Roll your own framework with a simple app system, like Django-GDAPS or CakePHP.</p> <p>GitHub</p>"},{"location":"third-party-packages/#dark-star","title":"Dark Star","text":"<p>A simple framework to help minimise the code needed to get HTML to the browser. Changes your file paths into Starlette routes and puts your view code right next to your template. Includes support for htmx to help enhance your frontend.</p> <p>Docs GitHub</p>"},{"location":"third-party-packages/#xpresso","title":"Xpresso","text":"<p>A flexible and extendable web framework built on top of Starlette, Pydantic and di.</p> <p>GitHub | Documentation</p>"},{"location":"third-party-packages/#ellar","title":"Ellar","text":"<p>GitHub | Documentation</p> <p>Ellar is an ASGI web framework for building fast, efficient and scalable RESTAPIs and server-side applications. It offers a high level of abstraction in building server-side applications and combines elements of OOP (Object Oriented Programming), and FP (Functional Programming) - Inspired by Nestjs.</p> <p>It is built on 3 core libraries Starlette, Pydantic, and injector.</p>"},{"location":"third-party-packages/#apiman","title":"Apiman","text":"<p>An extension to integrate Swagger/OpenAPI document easily for Starlette project and provide SwaggerUI and RedocUI.</p> <p>GitHub</p>"},{"location":"third-party-packages/#starlette-babel","title":"Starlette-Babel","text":"<p>Provides translations, localization, and timezone support via Babel integration.</p> <p>GitHub</p>"},{"location":"third-party-packages/#starlette-staticresources","title":"Starlette-StaticResources","text":"<p>GitHub</p> <p>Allows mounting package resources for static data, similar to StaticFiles.</p>"},{"location":"third-party-packages/#sentry","title":"Sentry","text":"<p>GitHub | Documentation</p> <p>Sentry is a software error detection tool. It offers actionable insights for resolving performance issues and errors, allowing users to diagnose, fix, and optimize Python debugging. Additionally, it integrates seamlessly with Starlette for Python application development. Sentry's capabilities include error tracking, performance insights, contextual information, and alerts/notifications.</p>"},{"location":"third-party-packages/#shiny","title":"Shiny","text":"<p>GitHub | Documentation</p> <p>Leveraging Starlette and asyncio, Shiny allows developers to create effortless Python web applications using the power of reactive programming. Shiny eliminates the hassle of manual state management, automatically determining the best execution path for your app at runtime while simultaneously minimizing re-rendering. This means that Shiny can support everything from the simplest dashboard to full-featured web apps.   </p>"},{"location":"threadpool/","title":"Thread Pool","text":"<p>Starlette uses a thread pool in several scenarios to avoid blocking the event loop:</p> <ul> <li>When you create a synchronous endpoint using <code>def</code> instead of <code>async def</code></li> <li>When serving files with <code>FileResponse</code></li> <li>When handling file uploads with <code>UploadFile</code></li> <li>When running synchronous background tasks with <code>BackgroundTask</code></li> <li>And some other scenarios that may not be documented...</li> </ul> <p>Starlette will run your code in a thread pool to avoid blocking the event loop. This applies for endpoint functions and background tasks you create, but also for internal Starlette code.</p> <p>To be more precise, Starlette uses <code>anyio.to_thread.run_sync</code> to run the synchronous code.</p>"},{"location":"threadpool/#concurrency-limitations","title":"Concurrency Limitations","text":"<p>The default thread pool size is only 40 tokens. This means that only 40 threads can run at the same time. This limit is shared with other libraries: for example FastAPI also uses <code>anyio</code> to run sync dependencies, which also uses up thread capacity.</p> <p>If you need to run more threads, you can increase the number of tokens:</p> <pre><code>import anyio.to_thread\n\nlimiter = anyio.to_thread.current_default_thread_limiter()\nlimiter.total_tokens = 100\n</code></pre> <p>The above code will increase the number of tokens to 100.</p> <p>Increasing the number of threads may have a performance and memory impact, so be careful when doing so.</p>"},{"location":"websockets/","title":"WebSockets","text":"<p>Starlette includes a <code>WebSocket</code> class that fulfils a similar role to the HTTP request, but that allows sending and receiving data on a websocket.</p>"},{"location":"websockets/#websocket","title":"WebSocket","text":"<p>Signature: <code>WebSocket(scope, receive=None, send=None)</code></p> <pre><code>from starlette.websockets import WebSocket\n\n\nasync def app(scope, receive, send):\n    websocket = WebSocket(scope=scope, receive=receive, send=send)\n    await websocket.accept()\n    await websocket.send_text('Hello, world!')\n    await websocket.close()\n</code></pre> <p>WebSockets present a mapping interface, so you can use them in the same way as a <code>scope</code>.</p> <p>For instance: <code>websocket['path']</code> will return the ASGI path.</p>"},{"location":"websockets/#url","title":"URL","text":"<p>The websocket URL is accessed as <code>websocket.url</code>.</p> <p>The property is actually a subclass of <code>str</code>, and also exposes all the components that can be parsed out of the URL.</p> <p>For example: <code>websocket.url.path</code>, <code>websocket.url.port</code>, <code>websocket.url.scheme</code>.</p>"},{"location":"websockets/#headers","title":"Headers","text":"<p>Headers are exposed as an immutable, case-insensitive, multi-dict.</p> <p>For example: <code>websocket.headers['sec-websocket-version']</code></p>"},{"location":"websockets/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are exposed as an immutable multi-dict.</p> <p>For example: <code>websocket.query_params['search']</code></p>"},{"location":"websockets/#path-parameters","title":"Path Parameters","text":"<p>Router path parameters are exposed as a dictionary interface.</p> <p>For example: <code>websocket.path_params['username']</code></p>"},{"location":"websockets/#accepting-the-connection","title":"Accepting the connection","text":"<ul> <li><code>await websocket.accept(subprotocol=None, headers=None)</code></li> </ul>"},{"location":"websockets/#sending-data","title":"Sending data","text":"<ul> <li><code>await websocket.send_text(data)</code></li> <li><code>await websocket.send_bytes(data)</code></li> <li><code>await websocket.send_json(data)</code></li> </ul> <p>JSON messages default to being sent over text data frames, from version 0.10.0 onwards. Use <code>websocket.send_json(data, mode=\"binary\")</code> to send JSON over binary data frames.</p>"},{"location":"websockets/#receiving-data","title":"Receiving data","text":"<ul> <li><code>await websocket.receive_text()</code></li> <li><code>await websocket.receive_bytes()</code></li> <li><code>await websocket.receive_json()</code></li> </ul> <p>May raise <code>starlette.websockets.WebSocketDisconnect()</code>.</p> <p>JSON messages default to being received over text data frames, from version 0.10.0 onwards. Use <code>websocket.receive_json(data, mode=\"binary\")</code> to receive JSON over binary data frames.</p>"},{"location":"websockets/#iterating-data","title":"Iterating data","text":"<ul> <li><code>websocket.iter_text()</code></li> <li><code>websocket.iter_bytes()</code></li> <li><code>websocket.iter_json()</code></li> </ul> <p>Similar to <code>receive_text</code>, <code>receive_bytes</code>, and <code>receive_json</code> but returns an async iterator.</p> <pre><code>from starlette.websockets import WebSocket\n\n\nasync def app(scope, receive, send):\n    websocket = WebSocket(scope=scope, receive=receive, send=send)\n    await websocket.accept()\n    async for message in websocket.iter_text():\n        await websocket.send_text(f\"Message text was: {message}\")\n    await websocket.close()\n</code></pre> <p>When <code>starlette.websockets.WebSocketDisconnect</code> is raised, the iterator will exit.</p>"},{"location":"websockets/#closing-the-connection","title":"Closing the connection","text":"<ul> <li><code>await websocket.close(code=1000, reason=None)</code></li> </ul>"},{"location":"websockets/#sending-and-receiving-messages","title":"Sending and receiving messages","text":"<p>If you need to send or receive raw ASGI messages then you should use <code>websocket.send()</code> and <code>websocket.receive()</code> rather than using the raw <code>send</code> and <code>receive</code> callables. This will ensure that the websocket's state is kept correctly updated.</p> <ul> <li><code>await websocket.send(message)</code></li> <li><code>await websocket.receive()</code></li> </ul>"},{"location":"websockets/#send-denial-response","title":"Send Denial Response","text":"<p>If you call <code>websocket.close()</code> before calling <code>websocket.accept()</code> then the server will automatically send a HTTP 403 error to the client.</p> <p>If you want to send a different error response, you can use the <code>websocket.send_denial_response()</code> method. This will send the response and then close the connection.</p> <ul> <li><code>await websocket.send_denial_response(response)</code></li> </ul> <p>This requires the ASGI server to support the WebSocket Denial Response extension. If it is not supported a <code>RuntimeError</code> will be raised.</p> <p>In the context of <code>Starlette</code>, you can also use the <code>HTTPException</code> to achieve the same result.</p> <pre><code>from starlette.applications import Starlette\nfrom starlette.exceptions import HTTPException\nfrom starlette.routing import WebSocketRoute\nfrom starlette.websockets import WebSocket\n\n\ndef is_authorized(subprotocols: list[str]):\n    if len(subprotocols) != 2:\n        return False\n    if subprotocols[0] != \"Authorization\":\n        return False\n    # Here we are hard coding the token, in a real application you would validate the token\n    # against a database or an external service.\n    if subprotocols[1] != \"token\":\n        return False\n    return True\n\n\nasync def websocket_endpoint(websocket: WebSocket):\n    subprotocols = websocket.scope[\"subprotocols\"]\n    if not is_authorized(subprotocols):\n        raise HTTPException(status_code=401, detail=\"Unauthorized\")\n    await websocket.accept(\"Authorization\")\n    await websocket.send_text(\"Hello, world!\")\n    await websocket.close()\n\n\napp = Starlette(debug=True, routes=[WebSocketRoute(\"/ws\", websocket_endpoint)])\n</code></pre>"}]}